{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"fastquadtree <p>Rust-optimized quadtree with a clean Python API</p> <p> </p> <p> </p> <p>"},{"location":"#why-use-fastquadtree","title":"Why use fastquadtree","text":"<ul> <li>Clean Python API with no external dependencies and modern typing hints</li> <li>The fastest quadtree Python package (&gt;10x faster than pyqtree)</li> <li>Prebuilt wheels for Windows, macOS, and Linux</li> <li>Support for inserting bounding boxes or points</li> <li>Fast KNN and range queries</li> <li>Optional object tracking for id \u2194 object mapping</li> <li>Fast serialization to/from bytes</li> <li>Support for multiple data types (f32, f64, i32, i64) for coordinates</li> <li>100% test coverage and CI on GitHub Actions</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>See examples of how fastquadtree can be used in the runnables section.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install fastquadtree\n</code></pre>"},{"location":"#import","title":"Import","text":"<pre><code>from fastquadtree import QuadTree  # Point handling\nfrom fastquadtree import RectQuadTree  # Bounding box handling\nfrom fastquadtree.pyqtree import Index # Drop-in replacement for pyqtree (6.567x faster while keeping the same API)\n</code></pre>"},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#query-insert-performance","title":"Query + Insert Performance","text":"<p>These benchmarks compare the total time to execute a set number of  queries and inserts across various Python spatial index libraries. Quadtrees are the focus of the benchmark, but Rtrees are included for reference.</p> <p> </p>"},{"location":"benchmark/#summary-largest-dataset-pyqtree-baseline","title":"Summary (largest dataset, PyQtree baseline)","text":"<ul> <li>Points: 250,000, Queries: 500</li> <li>Fastest total: fastquadtree at 0.100 s</li> </ul> Library Build (s) Query (s) Total (s) Speed vs PyQtree fastquadtree 0.027 0.073 0.100 16.12\u00d7 Shapely STRtree 0.148 0.083 0.231 7.00\u00d7 Rtree 0.814 0.245 1.059 1.53\u00d7 nontree-QuadTree 0.532 0.582 1.114 1.45\u00d7 e-pyquadtree 0.913 0.641 1.554 1.04\u00d7 PyQtree 1.352 0.264 1.616 1.00\u00d7 quads 1.231 0.465 1.695 0.95\u00d7"},{"location":"benchmark/#benchmark-configuration","title":"Benchmark Configuration","text":"Parameter Value Bounds (0, 0, 1000, 1000) Max points per node 128 Max depth 16 Queries per experiment 500"},{"location":"benchmark/#native-vs-shim","title":"Native vs Shim","text":""},{"location":"benchmark/#configuration","title":"Configuration","text":"<ul> <li>Points: 500,000</li> <li>Queries: 500</li> <li>Repeats: 5</li> </ul>"},{"location":"benchmark/#results","title":"Results","text":"Variant Build Query Total Native 0.134 1.873 2.007 Shim (no tracking) 0.245 1.815 2.060 Shim (tracking) 0.714 2.062 2.776"},{"location":"benchmark/#summary","title":"Summary","text":"<p>Using the shim with object tracking increases build time by 5.345x and query time by 1.101x. Total slowdown = 1.383x.</p> <p>Adding the object map tends to impact the build time more than query time.</p>"},{"location":"benchmark/#pyqtree-drop-in-shim-performance-gains","title":"pyqtree drop-in shim performance gains","text":""},{"location":"benchmark/#configuration_1","title":"Configuration","text":"<ul> <li>Points: 500,000</li> <li>Queries: 500</li> <li>Repeats: 5</li> </ul>"},{"location":"benchmark/#results_1","title":"Results","text":"Variant Build Query Total pyqtree (fastquadtree) 0.443 2.007 2.450 pyqtree (original) 3.233 12.857 16.091"},{"location":"benchmark/#summary_1","title":"Summary","text":"<p>If you directly replace pyqtree with the drop-in <code>fastquadtree.pyqtree.Index</code> shim, you get a build time of 0.443s and query time of 2.007s. This is a total speedup of 6.567x compared to the original pyqtree and requires no code changes.</p>"},{"location":"benchmark/#numpy-bulk-insert-vs-python-list-insert","title":"NumPy Bulk Insert vs Python List Insert","text":""},{"location":"benchmark/#configuration_2","title":"Configuration","text":"<ul> <li>Points: 500,000</li> <li>Repeats: 5</li> <li>Dtype: float32</li> <li>Track objects: False</li> </ul>"},{"location":"benchmark/#results-median-of-repeats","title":"Results (median of repeats)","text":"Variant Build time NumPy array direct 42.8 ms Python list insert only 51.1 ms Python list including conversion 540.2 ms <p>Key:  </p> <ul> <li>NumPy array direct: Using the <code>insert_many</code> method with a NumPy array of shape (N, 2).  </li> <li>Python list insert only: Using the <code>insert_many</code> method with a Python list of tuples.  </li> <li>Python list including conversion: Time taken to convert a NumPy array to a Python list of tuples, then inserting.  </li> </ul>"},{"location":"benchmark/#summary_2","title":"Summary","text":"<p>If your data is already in a NumPy array, using the <code>insert_many</code> method directly with the array is significantly faster than converting to a Python list first.</p>"},{"location":"benchmark/#serialization-vs-rebuild","title":"Serialization vs Rebuild","text":""},{"location":"benchmark/#configuration_3","title":"Configuration","text":"<ul> <li>Points: 1,000,000</li> <li>Capacity: 64</li> <li>Max depth: 10</li> <li>Repeats: 7</li> </ul>"},{"location":"benchmark/#results_2","title":"Results","text":"Variant Mean (s) Stdev (s) Serialize to bytes 0.021356 0.000937 Rebuild from points 0.106783 0.011430 Rebuild from bytes 0.021754 0.001687 Rebuild from file 0.024887 0.001846"},{"location":"benchmark/#summary_3","title":"Summary","text":"<ul> <li>Rebuild from bytes is 4.908747x faster than reinserting points.</li> <li>Rebuild from file is 4.290712x faster than reinserting points.</li> <li>Serialized blob size is 13,770,328 bytes.</li> </ul>"},{"location":"benchmark/#system-info","title":"System Info","text":"<ul> <li>OS: Windows 11 AMD64</li> <li>Python: CPython 3.12.2</li> <li>CPU: AMD Ryzen 7 3700X 8-Core Processor (16 threads)</li> <li>Memory: 31.9 GB</li> <li>GPU: NVIDIA GeForce RTX 5070 (11.9 GB)</li> </ul>"},{"location":"benchmark/#running-benchmarks","title":"Running Benchmarks","text":"<p>To run the benchmarks yourself, first install the dependencies:</p> <pre><code>pip install -r benchmarks/requirements.txt\n</code></pre> <p>Then run:</p> <pre><code>python benchmarks/cross_library_bench.py\npython benchmarks/benchmark_native_vs_shim.py \npython benchmarks/benchmark_np_vs_list.py \npython benchmarks/benchmark_serialization_vs_rebuild.py\n</code></pre> <p>Check the CLI arguments for the cross-library benchmark in <code>benchmarks/quadtree_bench/main.py</code>.</p>"},{"location":"future_features/","title":"Future Features","text":"<p>Below are a list of features that may be added to future versions of this project.  If you really want any of these features, please let us know by opening an issue.</p> <p>If you have any suggestions or would like to contribute, please feel free to open an issue or a pull request.</p> <p>The features will likely be implemented in the order they are listed below, but this is not guaranteed.</p>"},{"location":"future_features/#planned-features","title":"\ud83d\udea7 Planned Features","text":""},{"location":"future_features/#1-knn-with-criteria-function","title":"1. KNN with criteria function","text":"<p>Currently, KNN only supports finding the nearest neighbors based on euclidean distance. By adding a criteria function, we could allow users to define custom criteria for finding neighbors by passing a function that  takes in a point and returns a score. The KNN algorithm would then use this score to determine the nearest neighbors.</p>"},{"location":"future_features/#2-knn-in-rectangle-quadtree","title":"2. KNN in rectangle quadtree","text":"<p>Currently, KNN is only supported in the point quadtree. By adding KNN support to the rectangle quadtree, we could allow users to find the nearest rectangles to a given point. This would be to the nearest edge of the rectangle, adding complexity to the algorithm. However, it will allow for really quick collision detection between a point and a set of rectangles as the point can just do robust-collision handling with the nearest rectangles.</p>"},{"location":"future_features/#3-circle-support","title":"3. Circle support","text":"<p>Currently, we support points and rectangles in two separate quadtrees. For example, in the ball-pit demo, we use a point quadtree, but then query a larger area to account for the radius of the balls. With a circle quadtree, we could directly insert circles and perform circle-circle collision detection.</p> <p>A good alternative is to use the rectangle quadtree and insert the minimum bounding rectangles of the circles.</p>"},{"location":"future_features/#completed-planned-features","title":"\u2705 Completed Planned Features","text":"<p>Once a feature from above is completed, it will be moved to this section.</p>"},{"location":"future_features/#configurable-quadtree-coordinate-type-130","title":"Configurable Quadtree Coordinate Type (1.3.0)","text":"<p>Currently, the point quadtree only uses f32 for point coordinates, limiting precision in favor of better performance. To make the quadtree more flexible, we could allow users to specify the coordinate type (e.g., f64, i32, etc.) when creating a quadtree. The f32 will remain the default, but users will be able to specify a different type if needed.</p> <p>If the type cannot be made truly generic, then only the following types would be supported: f32, f64, i32, i64</p>"},{"location":"future_features/#quadtree-serialization-120","title":"Quadtree serialization (1.2.0)","text":"<p>By serializing the quadtree, we can save its state to a file and load it later. This will allow us to persist the quadtree structure and data across sessions. For example, you could pre build a quadtree with all the walls in your video game level, serialize it to a file, and then load it when the game starts. This will heavily reduce the game load time since you won't have to rebuild the quadtree from scratch every time.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Meet fastquadtree \u2014 a Rust powered spatial index for Python</p> <p>TLDR: create a tree, insert points, insert boxes, query ranges or nearest neighbors.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install fastquadtree\n</code></pre>"},{"location":"quickstart/#30-second-demo","title":"30-second demo","text":"<pre><code>from fastquadtree import QuadTree\n\n# 1) Make a tree that covers your world\nqt = QuadTree(bounds=(0, 0, 1000, 1000), capacity=20)\n\n# 2) Add some stuff (a, b, and c are auto-generated ids)\na = qt.insert((10, 10))                 \nb = qt.insert((200, 300))              \nc = qt.insert((999, 500))     \n\n# 3) Ask spatial questions\nprint(\"Range hits:\", qt.query((0, 0, 250, 350)))  # -&gt; [(id, x, y), ...]\n\nprint(\"Nearest to (210, 310):\", qt.nearest_neighbor((210, 310)))\n\nprint(\"Top 3 near (210, 310):\", qt.nearest_neighbors((210, 310), 3))\n\n# 4) Delete by id and exact location\nprint(\"Deleted:\", qt.delete(b, (200, 300)))\nprint(\"Count:\", qt.count_items())\n</code></pre>"},{"location":"quickstart/#range-queries-that-feel-natural","title":"Range queries that feel natural","text":"<pre><code># Think of it like a camera frustum in 2D\nviewport = (100, 200, 400, 600)\nfor id_, x, y in qt.query(viewport):\n    print(f\"Visible: id={id_} at ({x:.1f}, {y:.1f})\")\n</code></pre> <p>Use this for viewport culling, collision broad-phase, spatial filtering, and quick \u201cwhat is inside this box\u201d checks.</p>"},{"location":"quickstart/#nearest-neighbor-for-snapping-and-picking","title":"Nearest neighbor for snapping and picking","text":"<pre><code>cursor = (212, 305)\nhit = qt.nearest_neighbor(cursor)\nif hit:\n    id_, x, y = hit\n    print(f\"Closest to cursor is id={id_} at ({x:.1f}, {y:.1f})\")\n</code></pre> <p>Need more than one neighbor</p> <pre><code>for id_, x, y in qt.nearest_neighbors(cursor, k=5):\n    print(id_, x, y)\n</code></pre>"},{"location":"quickstart/#track-python-objects-when-you-need-them","title":"Track Python objects when you need them","text":"<p>Turn on object tracking to bind your own objects to ids. Object lookups for deletion are O(1).</p> <pre><code>qt = QuadTree((0, 0, 1000, 1000), capacity=16, track_objects=True)\n\nplayer = {\"name\": \"Alice\", \"hp\": 100}\nenemy  = {\"name\": \"Boblin\", \"hp\": 60}\n\npid = qt.insert((50, 50), obj=player)\neid = qt.insert((80, 60), obj=enemy)\n\n# Query as Item objects for convenience\nitems = qt.query((0, 0, 200, 200), as_items=True)\nfor it in items:\n    print(it.id, it.x, it.y, it.obj)\n\n# Remove by object identity\nqt.delete_by_object(player)            # True\n</code></pre> <p>Tip: leave <code>track_objects=False</code> for max speed when you do not need object mapping.</p>"},{"location":"quickstart/#reset-between-runs-without-breaking-references","title":"Reset between runs without breaking references","text":"<p>Keep the same <code>QuadTree</code> instance alive for UIs or game loops. Wipe contents and optionally reset ids.</p> <pre><code>qt.clear()  # tree is empty, auto ids start again at 0, all objects forgotten\n</code></pre>"},{"location":"quickstart/#tiny-benchmark-sketch","title":"Tiny benchmark sketch","text":"<pre><code>import random, time\nfrom fastquadtree import QuadTree\n\nN = 200_000\npts = [(random.random()*1000, random.random()*1000) for _ in range(N)]\nqt = QuadTree((0, 0, 1000, 1000), capacity=32)\n\nt0 = time.perf_counter()\nqt.insert_many(pts)\nt1 = time.perf_counter()\n\nhits = qt.query((250, 250, 750, 750))\nt2 = time.perf_counter()\n\nprint(f\"Build: {(t1-t0):.3f}s  Query: {(t2-t1):.3f}s  Hits: {len(hits)}\")\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common patterns","text":"<ul> <li>Use <code>capacity</code> 8 to 64 for most workloads   If data is highly skewed, set a <code>max_depth</code> to avoid very deep trees.</li> <li>Use <code>clear()</code> to reset when most points are moving rather than deleting and reinserting.</li> <li>Use <code>insert_many()</code> to bulk load a large batch of points at once.</li> </ul>"},{"location":"runnables/","title":"Runnable Examples","text":""},{"location":"runnables/#1-interactive-demo","title":"1. Interactive demo","text":"<ul> <li>Add and delete boids with mouse clicks</li> <li>Visualize KNN and range queries</li> </ul> <p>The interactive demo is a great way to see how fastquadtree works in practice. You can see how the quadtree subdivides as you add points, and validate the accuracy of the queries visually. By pressing 1, you can visualize the KNN query for each boid. </p> <pre><code>pip install -r interactive/requirements.txt\npython interactive/interactive_v2.py\n</code></pre> <p></p>"},{"location":"runnables/#15-interactive-demo-with-rectangles","title":"1.5 Interactive Demo with Rectangles","text":"<ul> <li>Similar to the above demo, but uses rectangles instead of points</li> <li>If the rectangles intersect at all with the query area, they will be highlighted in red</li> </ul> <p>If you are creating a game or simulation environment where entities have bounding boxes, you can use the rectangular quadtree to quickly check which entities are intersecting with another. </p> <pre><code>pip install -r interactive/requirements.txt\npython interactive/interactive_v2_rect.py\n</code></pre> <p></p>"},{"location":"runnables/#2-ball-pit","title":"2. Ball Pit","text":"<ul> <li>Spawn balls in a pit with physics-based collisions</li> <li>Easily switch between brute force and quadtree collision detection to see the performance difference</li> </ul> <p>The ball pit demo shows how quadtrees offer massive performance improvements for collision detection. Rectangular queries are used to find potential collisions, and then precise circle-circle collision checks are performed.</p> <pre><code>pip install -r interactive/requirements.txt\npython interactive/ball_pit.py\n</code></pre> <p></p>"},{"location":"api/point_item/","title":"fastquadtree.PointItem","text":"<p>               Bases: <code>Item</code></p> <p>Lightweight point item wrapper for tracking and as_items results.</p> <p>Attributes:</p> Name Type Description <code>id_</code> <code>int</code> <p>Integer identifier.</p> <code>geom</code> <code>Point | Bounds</code> <p>The point geometry as (x, y).</p> <code>obj</code> <code>Any | None</code> <p>The attached Python object if available, else None.</p>"},{"location":"api/point_item/#fastquadtree.PointItem.id_","title":"<code>id_ = id_</code>  <code>instance-attribute</code>","text":""},{"location":"api/point_item/#fastquadtree.PointItem.geom","title":"<code>geom = geom</code>  <code>instance-attribute</code>","text":""},{"location":"api/point_item/#fastquadtree.PointItem.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":""},{"location":"api/point_item/#fastquadtree.PointItem.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the item to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with 'id', 'geom', and 'obj' keys.</p>"},{"location":"api/point_item/#fastquadtree.PointItem.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize an item from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary with 'id', 'geom', and 'obj' keys.</p> required <p>Returns:</p> Type Description <code>Item</code> <p>An Item instance populated with the deserialized data.</p>"},{"location":"api/pyqtree/","title":"fastquadtree.pyqtree.Index","text":"<p>The interface of the class below is taken from the pyqtree package, but the implementation has been modified to use the fastquadtree package as a backend instead of the original pure-python implementation. Based on the benchmarks, this gives a overall performance boost of 6.514x. See the benchmark section of the docs for more details and the latest numbers.</p> <p>Index is  the top-level class for creating and using a quadtree spatial index with the original pyqtree interface. If you are not migrating from pyqtree, consider using the RectQuadTree class for detailed control and better performance.</p> <p>This class wraps a RectQuadTree instance and provides methods to insert items with bounding boxes, remove items, and query for items intersecting a given bounding box.</p> <p>Example usage: <pre><code>from fastquadtree.pyqtree import Index\n\n\nspindex = Index(bbox=(0, 0, 100, 100))\nspindex.insert('duck', (50, 30, 53, 60))\nspindex.insert('cookie', (10, 20, 15, 25))\nspindex.insert('python', (40, 50, 95, 90))\nresults = spindex.intersect((51, 51, 86, 86))\nsorted(results) # ['duck', 'python']\n</code></pre></p> <p>Initiate by specifying either 1) a bbox to keep track of, or 2) with an xy centerpoint and a width and height.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Iterable[SupportsFloat] | None</code> <p>The coordinate system bounding box of the area that the quadtree should keep track of, as a 4-length sequence (xmin,ymin,xmax,ymax)</p> <code>None</code> <code>x</code> <code>float | int | None</code> <p>The x center coordinate of the area that the quadtree should keep track of.</p> <code>None</code> <code>y</code> <code>float | int | None</code> <p>The y center coordinate of the area that the quadtree should keep track of.</p> <code>None</code> <code>width</code> <code>float | int | None</code> <p>How far from the xcenter that the quadtree should look when keeping track.</p> <code>None</code> <code>height</code> <code>float | int | None</code> <p>How far from the ycenter that the quadtree should look when keeping track</p> <code>None</code> <code>max_items</code> <code>optional</code> <p>The maximum number of items allowed per quad before splitting   up into four new subquads. Default is 10.</p> <code>MAX_ITEMS</code> <code>max_depth</code> <code>optional</code> <p>The maximum levels of nested subquads, after which no more splitting occurs and the bottommost quad nodes may grow indefinately. Default is 20.</p> <code>MAX_DEPTH</code> Note <p>Either the bbox argument must be set, or the x, y, width, and height arguments must be set.</p>"},{"location":"api/pyqtree/#fastquadtree.pyqtree.Index.insert","title":"<code>insert(item, bbox)</code>","text":"<p>Inserts an item into the quadtree along with its bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to insert into the index, which will be returned by the intersection method</p> required <code>bbox</code> <code>Iterable[SupportsFloat]</code> <p>The spatial bounding box tuple of the item, with four members (xmin,ymin,xmax,ymax)</p> required"},{"location":"api/pyqtree/#fastquadtree.pyqtree.Index.remove","title":"<code>remove(item, bbox)</code>","text":"<p>Removes an item from the quadtree.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to remove from the index</p> required <code>bbox</code> <code>Iterable[SupportsFloat]</code> <p>The spatial bounding box tuple of the item, with four members (xmin,ymin,xmax,ymax)</p> required Note <p>Both parameters need to exactly match the parameters provided to the insert method.</p>"},{"location":"api/pyqtree/#fastquadtree.pyqtree.Index.intersect","title":"<code>intersect(bbox)</code>","text":"<p>Intersects an input bounding box rectangle with all of the items contained in the quadtree.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Iterable[SupportsFloat]</code> <p>A spatial bounding box tuple with four members (xmin,ymin,xmax,ymax)</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of inserted items whose bounding boxes intersect with the input bbox.</p>"},{"location":"api/quadtree/","title":"fastquadtree.QuadTree","text":"<p>               Bases: <code>_BaseQuadTree[Point, _IdCoord, PointItem]</code></p> <p>Point version of the quadtree. All geometries are 2D points (x, y). High-level Python wrapper over the Rust quadtree engine.</p> Performance characteristics <p>Inserts: average O(log n)  Rect queries: average O(log n + k) where k is matches returned  Nearest neighbor: average O(log n) </p> Thread-safety <p>Instances are not thread-safe. Use external synchronization if you mutate the same tree from multiple threads.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Bounds</code> <p>World bounds as (min_x, min_y, max_x, max_y).</p> required <code>capacity</code> <code>int</code> <p>Max number of points per node before splitting.</p> required <code>max_depth</code> <code>int | None</code> <p>Optional max tree depth. If omitted, engine decides.</p> <code>None</code> <code>track_objects</code> <code>bool</code> <p>Enable id &lt;-&gt; object mapping inside Python.</p> <code>False</code> <code>dtype</code> <code>str</code> <p>Data type for coordinates and ids in the native engine. Default is 'f32'. Options are 'f32', 'f64', 'i32', 'i64'.</p> <code>'f32'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters are invalid or inserts are out of bounds.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the quadtree to a dict suitable for JSON or other serialization.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Includes a binary 'core' key for the native engine state, plus other metadata such as bounds and capacity and the obj store if tracking is enabled.</p> Example <pre><code>state = qt.to_dict()\nassert \"core\" in state and \"bounds\" in state\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.to_bytes","title":"<code>to_bytes()</code>","text":"<p>Serialize the quadtree to bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes representing the serialized quadtree. Can be saved as a file or loaded with <code>from_bytes()</code>.</p> Example <pre><code>blob = qt.to_bytes()\nwith open(\"tree.fqt\", \"wb\") as f:\n    f.write(blob)\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.from_bytes","title":"<code>from_bytes(data, dtype='f32')</code>  <code>classmethod</code>","text":"<p>Deserialize a quadtree from bytes. Specifiy the dtype if the original tree that was serialized used a non-default dtype.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes representing the serialized quadtree from <code>to_bytes()</code>.</p> required <code>dtype</code> <code>str</code> <p>The data type used in the native engine ('f32', 'f64', 'i32', 'i64') when saved to bytes.</p> <code>'f32'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new quadtree instance with the same state as when serialized.</p> Example <pre><code>blob = qt.to_bytes()\nqt2 = type(qt).from_bytes(blob)\nassert qt2.count_items() == qt.count_items()\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.insert","title":"<code>insert(geom, *, obj=None)</code>","text":"<p>Insert a single item.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Point (x, y) or Rect (x0, y0, x1, y1) depending on quadtree type.</p> required <code>obj</code> <code>Any | None</code> <p>Optional Python object to associate with id if tracking is enabled.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The id used for this insert.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If geometry is outside the tree bounds.</p> Example <pre><code>id0 = point_qt.insert((10.0, 20.0))  # for point trees\nid1 = rect_qt.insert((0.0, 0.0, 5.0, 5.0), obj=\"box\")  # for rect trees\nassert isinstance(id0, int) and isinstance(id1, int)\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.insert_many","title":"<code>insert_many(geoms, objs=None)</code>","text":"<pre><code>insert_many(geoms: Sequence[G], objs: list[Any] | None = None) -&gt; int\n</code></pre><pre><code>insert_many(geoms: NDArray[Any], objs: list[Any] | None = None) -&gt; int\n</code></pre> <p>Bulk insert with auto-assigned contiguous ids. Faster than inserting one-by-one. Can accept either a Python sequence of geometries or a NumPy array of shape (N,2) or (N,4) with a dtype that matches the quadtree's dtype.</p> <p>If tracking is enabled, the objects will be bulk stored internally. If no objects are provided, the items will have obj=None (if tracking).</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>NDArray[Any] | Sequence[G]</code> <p>List of geometries.</p> required <code>objs</code> <code>list[Any] | None</code> <p>Optional list of Python objects aligned with geoms.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of items inserted.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any geometry is outside bounds.</p> Example <pre><code>n = qt.insert_many([(1.0, 1.0), (2.0, 2.0)])\nassert n == 2\n\nimport numpy as np\narr = np.array([[3.0, 3.0], [4.0, 4.0]], dtype=np.float32)\nn2 = qt.insert_many(arr)\nassert n2 == 2\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.delete","title":"<code>delete(id_, geom)</code>","text":"<p>Delete an item by id and exact geometry.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The id of the item to delete.</p> required <code>geom</code> <code>G</code> <p>The geometry of the item to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the item was found and deleted.</p> Example <pre><code>i = qt.insert((1.0, 2.0))\nok = qt.delete(i, (1.0, 2.0))\nassert ok is True\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.attach","title":"<code>attach(id_, obj)</code>","text":"<p>Attach or replace the Python object for an existing id. Tracking must be enabled.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The id of the item to attach the object to.</p> required <code>obj</code> <code>Any</code> <p>The Python object to attach.</p> required Example <pre><code>i = qt.insert((2.0, 3.0), obj=None)\nqt.attach(i, {\"meta\": 123})\nassert qt.get(i) == {\"meta\": 123}\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.delete_by_object","title":"<code>delete_by_object(obj)</code>","text":"<p>Delete an item by Python object identity. Tracking must be enabled.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to delete.</p> required Example <pre><code>i = qt.insert((3.0, 4.0), obj=\"tag\")\nok = qt.delete_by_object(\"tag\")\nassert ok is True\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.clear","title":"<code>clear()</code>","text":"<p>Empty the tree in place, preserving bounds, capacity, and max_depth.</p> <p>If tracking is enabled, the id -&gt; object mapping is also cleared. The ids are reset to start at zero again.</p> Example <pre><code>_ = qt.insert((5.0, 6.0))\nqt.clear()\nassert qt.count_items() == 0 and len(qt) == 0\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.get_all_objects","title":"<code>get_all_objects()</code>","text":"<p>Return all tracked Python objects in the tree.</p> Example <pre><code>_ = qt.insert((7.0, 8.0), obj=\"a\")\n_ = qt.insert((9.0, 1.0), obj=\"b\")\nobjs = qt.get_all_objects()\nassert set(objs) == {\"a\", \"b\"}\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.get_all_items","title":"<code>get_all_items()</code>","text":"<p>Return all Item wrappers in the tree.</p> <p>Example:     <pre><code>_ = qt.insert((1.0, 1.0), obj=None)\nitems = qt.get_all_items()\nassert hasattr(items[0], \"id_\") and hasattr(items[0], \"geom\")\n</code></pre></p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.get_all_node_boundaries","title":"<code>get_all_node_boundaries()</code>","text":"<p>Return all node boundaries in the tree. Useful for visualization.</p> Example <pre><code>bounds = qt.get_all_node_boundaries()\nassert isinstance(bounds, list)\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.get","title":"<code>get(id_)</code>","text":"<p>Return the object associated with id, if tracking is enabled.</p> Example <pre><code>i = qt.insert((1.0, 2.0), obj={\"k\": \"v\"})\nobj = qt.get(i)\nassert obj == {\"k\": \"v\"}\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.count_items","title":"<code>count_items()</code>","text":"<p>Return the number of items currently in the tree (native count).</p> Example <pre><code>before = qt.count_items()\n_ = qt.insert((2.0, 2.0))\nassert qt.count_items() == before + 1\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.query","title":"<code>query(rect, *, as_items=False)</code>","text":"<pre><code>query(rect: Bounds, *, as_items: Literal[False] = ...) -&gt; list[_IdCoord]\n</code></pre><pre><code>query(rect: Bounds, *, as_items: Literal[True]) -&gt; list[PointItem]\n</code></pre> <p>Return all points inside an axis-aligned rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <code>as_items</code> <code>bool</code> <p>If True, return Item wrappers. If False, return raw tuples.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[PointItem] | list[_IdCoord]</code> <p>If as_items is False: list of (id, x, y) tuples.</p> <code>list[PointItem] | list[_IdCoord]</code> <p>If as_items is True: list of Item objects.</p> Example <pre><code>results = qt.query((10.0, 10.0, 20.0, 20.0), as_items=True)\nfor item in results:\n    print(f\"Found point id={item.id_} at {item.geom} with obj={item.obj}\")\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.nearest_neighbor","title":"<code>nearest_neighbor(xy, *, as_item=False)</code>","text":"<pre><code>nearest_neighbor(xy: Point, *, as_item: Literal[False] = ...) -&gt; _IdCoord | None\n</code></pre><pre><code>nearest_neighbor(xy: Point, *, as_item: Literal[True]) -&gt; PointItem | None\n</code></pre> <p>Return the single nearest neighbor to the query point.</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>Point</code> <p>Query point (x, y).</p> required <code>as_item</code> <code>bool</code> <p>If True, return Item. If False, return (id, x, y).</p> <code>False</code> <p>Returns:</p> Type Description <code>PointItem | _IdCoord | None</code> <p>The nearest neighbor or None if the tree is empty.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.nearest_neighbors","title":"<code>nearest_neighbors(xy, k, *, as_items=False)</code>","text":"<pre><code>nearest_neighbors(xy: Point, k: int, *, as_items: Literal[False] = ...) -&gt; list[_IdCoord]\n</code></pre><pre><code>nearest_neighbors(xy: Point, k: int, *, as_items: Literal[True]) -&gt; list[PointItem]\n</code></pre> <p>Return the k nearest neighbors to the query point in order of increasing distance.</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <code>as_items</code> <code>bool</code> <p>If True, return Item wrappers. If False, return raw tuples.</p> <code>False</code> <p>Returns:     If as_items is False: list of (id, x, y) tuples.     If as_items is True: list of Item objects.</p>"},{"location":"api/rect_item/","title":"fastquadtree.RectItem","text":"<p>               Bases: <code>Item</code></p> <p>Lightweight rectangle item wrapper for tracking and as_items results.</p> <p>Attributes:</p> Name Type Description <code>id_</code> <code>int</code> <p>Integer identifier.</p> <code>geom</code> <code>Point | Bounds</code> <p>The rectangle geometry as (min_x, min_y, max_x, max_y</p> <code>obj</code> <code>Any | None</code> <p>The attached Python object if available, else None.</p>"},{"location":"api/rect_item/#fastquadtree.RectItem.id_","title":"<code>id_ = id_</code>  <code>instance-attribute</code>","text":""},{"location":"api/rect_item/#fastquadtree.RectItem.geom","title":"<code>geom = geom</code>  <code>instance-attribute</code>","text":""},{"location":"api/rect_item/#fastquadtree.RectItem.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":""},{"location":"api/rect_item/#fastquadtree.RectItem.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the item to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with 'id', 'geom', and 'obj' keys.</p>"},{"location":"api/rect_item/#fastquadtree.RectItem.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize an item from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary with 'id', 'geom', and 'obj' keys.</p> required <p>Returns:</p> Type Description <code>Item</code> <p>An Item instance populated with the deserialized data.</p>"},{"location":"api/rect_quadtree/","title":"fastquadtree.RectQuadTree","text":"<p>               Bases: <code>_BaseQuadTree[Bounds, _IdRect, RectItem]</code></p> <p>Rectangle version of the quadtree. All geometries are axis-aligned rectangles. (min_x, min_y, max_x, max_y) High-level Python wrapper over the Rust quadtree engine.</p> Performance characteristics <p>Inserts: average O(log n)  Rect queries: average O(log n + k) where k is matches returned  Nearest neighbor: average O(log n) </p> Thread-safety <p>Instances are not thread-safe. Use external synchronization if you mutate the same tree from multiple threads.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Bounds</code> <p>World bounds as (min_x, min_y, max_x, max_y).</p> required <code>capacity</code> <code>int</code> <p>Max number of points per node before splitting.</p> required <code>max_depth</code> <code>int | None</code> <p>Optional max tree depth. If omitted, engine decides.</p> <code>None</code> <code>track_objects</code> <code>bool</code> <p>Enable id &lt;-&gt; object mapping inside Python.</p> <code>False</code> <code>dtype</code> <code>str</code> <p>Data type for coordinates and ids in the native engine. Default is 'f32'. Options are 'f32', 'f64', 'i32', 'i64'.</p> <code>'f32'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters are invalid or inserts are out of bounds.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the quadtree to a dict suitable for JSON or other serialization.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Includes a binary 'core' key for the native engine state, plus other metadata such as bounds and capacity and the obj store if tracking is enabled.</p> Example <pre><code>state = qt.to_dict()\nassert \"core\" in state and \"bounds\" in state\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.to_bytes","title":"<code>to_bytes()</code>","text":"<p>Serialize the quadtree to bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes representing the serialized quadtree. Can be saved as a file or loaded with <code>from_bytes()</code>.</p> Example <pre><code>blob = qt.to_bytes()\nwith open(\"tree.fqt\", \"wb\") as f:\n    f.write(blob)\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.from_bytes","title":"<code>from_bytes(data, dtype='f32')</code>  <code>classmethod</code>","text":"<p>Deserialize a quadtree from bytes. Specifiy the dtype if the original tree that was serialized used a non-default dtype.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes representing the serialized quadtree from <code>to_bytes()</code>.</p> required <code>dtype</code> <code>str</code> <p>The data type used in the native engine ('f32', 'f64', 'i32', 'i64') when saved to bytes.</p> <code>'f32'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new quadtree instance with the same state as when serialized.</p> Example <pre><code>blob = qt.to_bytes()\nqt2 = type(qt).from_bytes(blob)\nassert qt2.count_items() == qt.count_items()\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.insert","title":"<code>insert(geom, *, obj=None)</code>","text":"<p>Insert a single item.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Point (x, y) or Rect (x0, y0, x1, y1) depending on quadtree type.</p> required <code>obj</code> <code>Any | None</code> <p>Optional Python object to associate with id if tracking is enabled.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The id used for this insert.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If geometry is outside the tree bounds.</p> Example <pre><code>id0 = point_qt.insert((10.0, 20.0))  # for point trees\nid1 = rect_qt.insert((0.0, 0.0, 5.0, 5.0), obj=\"box\")  # for rect trees\nassert isinstance(id0, int) and isinstance(id1, int)\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.insert_many","title":"<code>insert_many(geoms, objs=None)</code>","text":"<pre><code>insert_many(geoms: Sequence[G], objs: list[Any] | None = None) -&gt; int\n</code></pre><pre><code>insert_many(geoms: NDArray[Any], objs: list[Any] | None = None) -&gt; int\n</code></pre> <p>Bulk insert with auto-assigned contiguous ids. Faster than inserting one-by-one. Can accept either a Python sequence of geometries or a NumPy array of shape (N,2) or (N,4) with a dtype that matches the quadtree's dtype.</p> <p>If tracking is enabled, the objects will be bulk stored internally. If no objects are provided, the items will have obj=None (if tracking).</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>NDArray[Any] | Sequence[G]</code> <p>List of geometries.</p> required <code>objs</code> <code>list[Any] | None</code> <p>Optional list of Python objects aligned with geoms.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of items inserted.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any geometry is outside bounds.</p> Example <pre><code>n = qt.insert_many([(1.0, 1.0), (2.0, 2.0)])\nassert n == 2\n\nimport numpy as np\narr = np.array([[3.0, 3.0], [4.0, 4.0]], dtype=np.float32)\nn2 = qt.insert_many(arr)\nassert n2 == 2\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.delete","title":"<code>delete(id_, geom)</code>","text":"<p>Delete an item by id and exact geometry.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The id of the item to delete.</p> required <code>geom</code> <code>G</code> <p>The geometry of the item to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the item was found and deleted.</p> Example <pre><code>i = qt.insert((1.0, 2.0))\nok = qt.delete(i, (1.0, 2.0))\nassert ok is True\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.attach","title":"<code>attach(id_, obj)</code>","text":"<p>Attach or replace the Python object for an existing id. Tracking must be enabled.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The id of the item to attach the object to.</p> required <code>obj</code> <code>Any</code> <p>The Python object to attach.</p> required Example <pre><code>i = qt.insert((2.0, 3.0), obj=None)\nqt.attach(i, {\"meta\": 123})\nassert qt.get(i) == {\"meta\": 123}\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.delete_by_object","title":"<code>delete_by_object(obj)</code>","text":"<p>Delete an item by Python object identity. Tracking must be enabled.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to delete.</p> required Example <pre><code>i = qt.insert((3.0, 4.0), obj=\"tag\")\nok = qt.delete_by_object(\"tag\")\nassert ok is True\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.clear","title":"<code>clear()</code>","text":"<p>Empty the tree in place, preserving bounds, capacity, and max_depth.</p> <p>If tracking is enabled, the id -&gt; object mapping is also cleared. The ids are reset to start at zero again.</p> Example <pre><code>_ = qt.insert((5.0, 6.0))\nqt.clear()\nassert qt.count_items() == 0 and len(qt) == 0\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.get_all_objects","title":"<code>get_all_objects()</code>","text":"<p>Return all tracked Python objects in the tree.</p> Example <pre><code>_ = qt.insert((7.0, 8.0), obj=\"a\")\n_ = qt.insert((9.0, 1.0), obj=\"b\")\nobjs = qt.get_all_objects()\nassert set(objs) == {\"a\", \"b\"}\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.get_all_items","title":"<code>get_all_items()</code>","text":"<p>Return all Item wrappers in the tree.</p> <p>Example:     <pre><code>_ = qt.insert((1.0, 1.0), obj=None)\nitems = qt.get_all_items()\nassert hasattr(items[0], \"id_\") and hasattr(items[0], \"geom\")\n</code></pre></p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.get_all_node_boundaries","title":"<code>get_all_node_boundaries()</code>","text":"<p>Return all node boundaries in the tree. Useful for visualization.</p> Example <pre><code>bounds = qt.get_all_node_boundaries()\nassert isinstance(bounds, list)\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.get","title":"<code>get(id_)</code>","text":"<p>Return the object associated with id, if tracking is enabled.</p> Example <pre><code>i = qt.insert((1.0, 2.0), obj={\"k\": \"v\"})\nobj = qt.get(i)\nassert obj == {\"k\": \"v\"}\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.count_items","title":"<code>count_items()</code>","text":"<p>Return the number of items currently in the tree (native count).</p> Example <pre><code>before = qt.count_items()\n_ = qt.insert((2.0, 2.0))\nassert qt.count_items() == before + 1\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.query","title":"<code>query(rect, *, as_items=False)</code>","text":"<pre><code>query(rect: Bounds, *, as_items: Literal[False] = ...) -&gt; list[_IdRect]\n</code></pre><pre><code>query(rect: Bounds, *, as_items: Literal[True]) -&gt; list[RectItem]\n</code></pre> <p>Query the tree for all items that intersect the given rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <code>as_items</code> <code>bool</code> <p>If True, return Item wrappers. If False, return raw tuples.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[_IdRect] | list[RectItem]</code> <p>If as_items is False: list of (id, x0, y0, x1, y1) tuples.</p> <code>list[_IdRect] | list[RectItem]</code> <p>If as_items is True: list of Item objects.</p> Example <pre><code>results = rqt.query((10.0, 10.0, 20.0, 20.0), as_items=True)\nfor item in results:\n    print(f\"Found rect id={item.id_} at {item.geom} with obj={item.obj}\")\n</code></pre>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"fastquadtree <p>Rust-optimized quadtree with a clean Python API</p> <p> </p> <p> </p> <p>"},{"location":"#why-use-fastquadtree","title":"Why use fastquadtree","text":"<ul> <li>Just pip install: prebuilt wheels for Windows, macOS, and Linux (no Rust or compiler needed)</li> <li>The fastest quadtree Python package (&gt;10x faster than pyqtree)</li> <li>Clean Python API with no external dependencies and modern typing hints</li> <li>Support for inserting bounding boxes or points</li> <li>Fast KNN and range queries</li> <li>Optional object tracking for id \u2194 object mapping</li> <li>Fast serialization to/from bytes</li> <li>Support for multiple data types (f32, f64, i32, i64) for coordinates</li> <li>100% test coverage and CI on GitHub Actions</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>See examples of how fastquadtree can be used in the runnables section.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install fastquadtree\n</code></pre>"},{"location":"#import","title":"Import","text":"<pre><code>from fastquadtree import QuadTree  # Point handling\nfrom fastquadtree import RectQuadTree  # Bounding box handling\nfrom fastquadtree import QuadTreeObjects  # Point handling with object tracking\nfrom fastquadtree import RectQuadTreeObjects  # Bounding box handling with object tracking\nfrom fastquadtree.pyqtree import Index # Drop-in replacement for pyqtree (~10x faster while keeping the same API)\n</code></pre>"},{"location":"2.0_migration_guide/","title":"Migration Guide: v1.x to v2.0","text":"<p>This guide covers all breaking changes in fastquadtree 2.0 and how to update your code.</p>"},{"location":"2.0_migration_guide/#overview-of-breaking-changes","title":"Overview of Breaking Changes","text":"Change Impact Class split <code>track_objects=True</code> users must switch to <code>*Objects</code> classes Query return types <code>as_items</code> parameter removed NumPy methods Runtime type detection removed; use explicit <code>_np</code> methods Insertion API <code>insert_many</code> returns <code>InsertResult</code> instead of <code>int</code> Deletion API Signature changed from <code>delete(id_, geom)</code> to <code>delete(id_, x, y, ...)</code> Custom IDs New feature for non-Objects classes Serialization New format; v1 serialized data not compatible Removed methods <code>count_items()</code> removed; use <code>len()</code>"},{"location":"2.0_migration_guide/#class-split","title":"Class Split","text":"<p>The <code>track_objects</code> parameter has been removed. Instead, use the appropriate class for your use case.</p>"},{"location":"2.0_migration_guide/#choosing-your-class","title":"Choosing Your Class","text":"v1.x Usage v2.0 Class <code>QuadTree(..., track_objects=False)</code> <code>QuadTree</code> <code>QuadTree(..., track_objects=True)</code> <code>QuadTreeObjects</code> <code>RectQuadTree(..., track_objects=False)</code> <code>RectQuadTree</code> <code>RectQuadTree(..., track_objects=True)</code> <code>RectQuadTreeObjects</code>"},{"location":"2.0_migration_guide/#before-v1x","title":"Before (v1.x)","text":"<pre><code>from fastquadtree import QuadTree, RectQuadTree\n\n# Without object tracking\nqt = QuadTree((0, 0, 100, 100), capacity=4, track_objects=False)\n\n# With object tracking\nqt_tracked = QuadTree((0, 0, 100, 100), capacity=4, track_objects=True)\nqt_tracked.insert((10, 20), obj={\"name\": \"point_a\"})\n</code></pre>"},{"location":"2.0_migration_guide/#after-v20","title":"After (v2.0)","text":"<pre><code>from fastquadtree import (\n    QuadTree,\n    QuadTreeObjects,\n    RectQuadTree,\n    RectQuadTreeObjects,\n)\n\n# Without object tracking (default, fastest)\nqt = QuadTree((0, 0, 100, 100), capacity=4)\n\n# With object tracking\nqt_tracked = QuadTreeObjects((0, 0, 100, 100), capacity=4)\nqt_tracked.insert((10, 20), obj={\"name\": \"point_a\"})\n</code></pre>"},{"location":"2.0_migration_guide/#query-return-types","title":"Query Return Types","text":"<p>The <code>as_items</code> parameter has been removed. Return types are now determined by which class you use.</p>"},{"location":"2.0_migration_guide/#before-v1x_1","title":"Before (v1.x)","text":"<pre><code># Tuple output (default)\nresults = qt.query(rect)\nfor id_, x, y in results:\n    ...\n\n# Item output\nresults = qt.query(rect, as_items=True)\nfor item in results:\n    print(item.id_, item.x, item.y, item.obj)\n</code></pre>"},{"location":"2.0_migration_guide/#after-v20_1","title":"After (v2.0)","text":"<pre><code># QuadTree always returns tuples\nresults = qt.query(rect)\nfor id_, x, y in results:\n    ...\n\n# QuadTreeObjects always returns PointItem objects\nresults = qt_obj.query(rect)\nfor item in results:\n    print(item.id_, item.x, item.y, item.obj)\n\n# If you only need IDs from an Objects tree (fast path)\nids = qt_obj.query_ids(rect)\n</code></pre>"},{"location":"2.0_migration_guide/#numpy-methods","title":"NumPy Methods","text":"<p>Runtime type detection has been removed. NumPy arrays are no longer accepted by standard methods.</p>"},{"location":"2.0_migration_guide/#before-v1x_2","title":"Before (v1.x)","text":"<pre><code>import numpy as np\n\n# Same method accepted both\nqt.insert_many([(1, 2), (3, 4)])\nqt.insert_many(np.array([[1, 2], [3, 4]], dtype=np.float32))\n</code></pre>"},{"location":"2.0_migration_guide/#after-v20_2","title":"After (v2.0)","text":"<pre><code>import numpy as np\n\n# Python sequences use standard methods\nqt.insert_many([(1, 2), (3, 4)])\n\n# NumPy arrays require _np methods\nqt.insert_many_np(np.array([[1, 2], [3, 4]], dtype=np.float32))\n\n# Same pattern for queries\nresults = qt.query(rect)                  # list output\nids, coords = qt.query_np(rect)           # NumPy output\n\n# And nearest neighbors\nneighbors = qt.nearest_neighbors(point, k=5)\nids, coords = qt.nearest_neighbors_np(point, k=5)\n</code></pre> <p>TypeError on misuse</p> <p>Passing a NumPy array to a non-<code>_np</code> method raises <code>TypeError</code>. This catches bugs early rather than silently degrading performance.</p>"},{"location":"2.0_migration_guide/#numpy-output-guarantees","title":"NumPy Output Guarantees","text":"<p>All <code>_np</code> methods return arrays with consistent dtypes:</p> <ul> <li><code>ids</code>: <code>np.uint64</code>, shape <code>(N,)</code></li> <li><code>coords</code>: <code>np.float32</code>, <code>np.float64</code>, <code>np.int32</code>, or <code>np.int64</code> (matches tree's <code>dtype</code>), shape <code>(N, 2)</code> for points or <code>(N, 4)</code> for rects</li> </ul>"},{"location":"2.0_migration_guide/#insertion-api","title":"Insertion API","text":""},{"location":"2.0_migration_guide/#single-insert","title":"Single Insert","text":"<p>Single <code>insert()</code> still returns an <code>int</code> ID. No change required unless you want to use custom IDs (see Custom IDs).</p>"},{"location":"2.0_migration_guide/#bulk-insert","title":"Bulk Insert","text":"<p><code>insert_many()</code> now returns an <code>InsertResult</code> dataclass instead of an <code>int</code> or <code>tuple</code>.</p>"},{"location":"2.0_migration_guide/#before-v1x_3","title":"Before (v1.x)","text":"<pre><code># Count only\ncount = qt.insert_many(points)\n\n# Count and start ID\ncount, start_id = qt.insert_many(points, get_start_id=True)\n</code></pre>"},{"location":"2.0_migration_guide/#after-v20_3","title":"After (v2.0)","text":"<pre><code>result = qt.insert_many(points)\n\nresult.count      # number inserted\nresult.start_id   # first ID in batch\nresult.end_id     # last ID in batch\nresult.ids        # range(start_id, end_id + 1)\n</code></pre>"},{"location":"2.0_migration_guide/#quick-fix","title":"Quick Fix","text":"<p>If you have many call sites, a wrapper function eases migration:</p> <pre><code>def insert_many_v1(qt, geoms, get_start_id=False):\n    \"\"\"Compatibility wrapper returning v1-style output.\"\"\"\n    result = qt.insert_many(geoms)\n    if get_start_id:\n        return result.count, result.start_id\n    return result.count\n</code></pre>"},{"location":"2.0_migration_guide/#deletion-api","title":"Deletion API","text":""},{"location":"2.0_migration_guide/#non-objects-classes","title":"Non-Objects Classes","text":"<p>Geometry is now passed as separate arguments, not a tuple.</p>"},{"location":"2.0_migration_guide/#before-v1x_4","title":"Before (v1.x)","text":"<pre><code># Points\nqt.delete(id_, (x, y))\n\n# Rects\nrqt.delete(id_, (min_x, min_y, max_x, max_y))\n</code></pre>"},{"location":"2.0_migration_guide/#after-v20_4","title":"After (v2.0)","text":"<pre><code># Points\nqt.delete(id_, x, y)\n\n# Rects\nrqt.delete(id_, min_x, min_y, max_x, max_y)\n</code></pre>"},{"location":"2.0_migration_guide/#objects-classes","title":"Objects Classes","text":"<p>Objects classes can delete by ID alone since they track coordinates internally.</p> <pre><code># Delete by ID (Objects classes only)\nqt_obj.delete(id_)\n\n# Delete by location (removes lowest ID at that point)\nqt_obj.delete_at(x, y)\n\n# Delete by object identity\nqt_obj.delete_by_object(obj)        # deletes all matches, returns count\nqt_obj.delete_one_by_object(obj)    # deletes one match, returns bool\n</code></pre>"},{"location":"2.0_migration_guide/#custom-ids","title":"Custom IDs","text":"<p>New in v2.0. Non-Objects classes now support user-provided IDs on single inserts.</p> <pre><code># Auto-assigned (default)\nid_ = qt.insert((10, 20))\n\n# Custom ID\nqt.insert((10, 20), id_=42)\nqt.insert((30, 40), id_=1000)\n</code></pre> <p>This is useful when correlating quadtree entries with external data structures like lists or database rows.</p> <p>Collision Warning</p> <p>The quadtree does not validate ID uniqueness. Mixing auto-assigned and custom IDs, or reusing custom IDs, leads to undefined behavior on deletion and update. If you use custom IDs, you are responsible for ensuring uniqueness.</p> <p><code>QuadTreeObjects</code> does not support custom IDs because it uses dense ID allocation for efficient object lookup.</p>"},{"location":"2.0_migration_guide/#updatemove-api","title":"Update/Move API","text":"<p>Moving items requires coordinates for non-Objects classes (which don't store them internally).</p>"},{"location":"2.0_migration_guide/#points","title":"Points","text":"<pre><code># QuadTree: must provide old coordinates\nqt.update(id_, old_x, old_y, new_x, new_y)\n\n# QuadTreeObjects: only needs new coordinates\nqt_obj.update(id_, new_x, new_y)\n</code></pre>"},{"location":"2.0_migration_guide/#rects","title":"Rects","text":"<pre><code># RectQuadTree: must provide old coordinates\nrqt.update(id_, old_min_x, old_min_y, old_max_x, old_max_y, new_min_x, new_min_y, new_max_x, new_max_y)\n\n# RectQuadTreeObjects: only needs new coordinates\nrqt_obj.update(id_, new_min_x, new_min_y, new_max_x, new_max_y)\n</code></pre>"},{"location":"2.0_migration_guide/#serialization","title":"Serialization","text":"<p>The serialization format has changed. v1 serialized data cannot be loaded in v2.</p>"},{"location":"2.0_migration_guide/#before-v1x_5","title":"Before (v1.x)","text":"<pre><code># Dict-based (removed)\nstate = qt.to_dict()\nqt2 = QuadTree.from_dict(state)\n\n# Bytes with explicit dtype on load\ndata = qt.to_bytes()\nqt2 = QuadTree.from_bytes(data, dtype=\"f32\")\n</code></pre>"},{"location":"2.0_migration_guide/#after-v20_5","title":"After (v2.0)","text":"<pre><code># Bytes only, dtype encoded in payload\ndata = qt.to_bytes()\nqt2 = QuadTree.from_bytes(data)\n</code></pre>"},{"location":"2.0_migration_guide/#objects-classes_1","title":"Objects Classes","text":"<p>Object serialization is now explicit and guarded for safety.</p> <pre><code># Without objects (default)\ndata = qt_obj.to_bytes()\ndata = qt_obj.to_bytes(include_objects=False)  # equivalent\n\n# With objects (opt-in)\ndata = qt_obj.to_bytes(include_objects=True)\n\n# Loading requires explicit opt-in for objects\nqt2 = QuadTreeObjects.from_bytes(data)                        # objects ignored\nqt2 = QuadTreeObjects.from_bytes(data, allow_objects=True)    # objects loaded\n</code></pre> <p>Security Note</p> <p>Object deserialization uses pickle-like semantics. Never load serialized data from untrusted sources with <code>allow_objects=True</code>.</p>"},{"location":"2.0_migration_guide/#migrating-persisted-data","title":"Migrating Persisted Data","text":"<p>If you have v1 serialized data you need to preserve:</p> <ol> <li>Load it with fastquadtree 1.x</li> <li>Extract the raw point/rect data</li> <li>Re-insert into a v2 tree</li> <li>Save with the new format</li> </ol> <pre><code># Migration script (run with v1.x installed)\nimport fastquadtree as fqt_v1\nimport pickle\n\n# Load old data\nwith open(\"tree_v1.fqt\", \"rb\") as f:\n    old_data = pickle.load(f)\n\n# Extract items (adjust based on your tree type)\nitems = [...]  # extract from old_data\n\n# Save as intermediate format\nwith open(\"tree_items.pkl\", \"wb\") as f:\n    pickle.dump(items, f)\n</code></pre> <pre><code># Rebuild script (run with v2.0 installed)\nimport fastquadtree as fqt\nimport pickle\n\nwith open(\"tree_items.pkl\", \"rb\") as f:\n    items = pickle.load(f)\n\nqt = fqt.QuadTree((0, 0, 100, 100), capacity=4)\nfor x, y in items:\n    qt.insert((x, y))\n\nqt.to_bytes()  # new format\n</code></pre>"},{"location":"2.0_migration_guide/#removed-methods","title":"Removed Methods","text":"v1.x v2.0 Replacement <code>qt.count_items()</code> <code>len(qt)</code> <code>qt.to_dict()</code> <code>qt.to_bytes()</code>"},{"location":"2.0_migration_guide/#new-features-in-v20","title":"New Features in v2.0","text":"<p>These are non-breaking additions you can start using:</p>"},{"location":"2.0_migration_guide/#__contains__","title":"<code>__contains__</code>","text":"<pre><code>if (10.0, 20.0) in qt:\n    print(\"Point exists\")\n</code></pre>"},{"location":"2.0_migration_guide/#iteration","title":"Iteration","text":"<pre><code># QuadTree\nfor id_, x, y in qt:\n    ...\n\n# QuadTreeObjects\nfor item in qt_obj:\n    print(item.id_, item.x, item.y, item.obj)\n</code></pre>"},{"location":"2.0_migration_guide/#query_ids-objects-classes","title":"<code>query_ids</code> (Objects classes)","text":"<p>Fast path when you only need IDs:</p> <pre><code>ids = qt_obj.query_ids(rect)  # list[int]\n</code></pre>"},{"location":"2.0_migration_guide/#update_by_object-objects-classes","title":"<code>update_by_object</code> (Objects classes)","text":"<p>Convenience method to update an item by finding it via its associated object:</p> <pre><code># Points\nqt_obj.update_by_object(obj, new_x, new_y)\n\n# Rects\nrqt_obj.update_by_object(obj, new_min_x, new_min_y, new_max_x, new_max_y)\n</code></pre> <p>If multiple items have the same object, updates the one with the lowest ID. Returns <code>True</code> if the item was found and updated, <code>False</code> otherwise.</p>"},{"location":"2.0_migration_guide/#quick-reference","title":"Quick Reference","text":""},{"location":"2.0_migration_guide/#find-and-replace-patterns","title":"Find and Replace Patterns","text":"Find Replace <code>QuadTree(..., track_objects=True)</code> <code>QuadTreeObjects(...)</code> <code>RectQuadTree(..., track_objects=True)</code> <code>RectQuadTreeObjects(...)</code> <code>, track_objects=False</code> (remove) <code>, as_items=True</code> (remove, switch to Objects class) <code>, as_items=False</code> (remove) <code>.insert_many(np_array)</code> <code>.insert_many_np(np_array)</code> <code>.query(rect, as_items=...)</code> <code>.query(rect)</code> <code>.delete(id_, (x, y))</code> <code>.delete(id_, x, y)</code> <code>.count_items()</code> <code>len(...)</code>"},{"location":"2.0_migration_guide/#import-template","title":"Import Template","text":"<pre><code>from fastquadtree import (\n    QuadTree,\n    QuadTreeObjects,\n    RectQuadTree,\n    RectQuadTreeObjects,\n    InsertResult,\n    PointItem,\n    RectItem,\n)\n</code></pre>"},{"location":"2.0_proposal/","title":"2.0 proposal","text":""},{"location":"2.0_proposal/#fastquadtree-20-proposal","title":"fastquadtree 2.0 Proposal","text":"<p>This document describes the breaking changes planned for fastquadtree v2.0. The goals are:</p> <ul> <li>A simpler, more predictable Python API</li> <li>Zero overhead for users who do not need object association</li> <li>First-class NumPy workflows without runtime type branching</li> <li>Safer, more explicit semantics around precision limits and serialization</li> </ul>"},{"location":"2.0_proposal/#target-audiences","title":"Target Audiences","text":"<ul> <li>New Python developers: intuitive classes, predictable return types</li> <li>Performance-focused users: fastest possible hot paths, minimal memory overhead</li> <li>Scientific users: consistent NumPy I/O shapes and dtypes, clean data handling</li> </ul>"},{"location":"2.0_proposal/#overview-of-v20-direction","title":"Overview of v2.0 Direction","text":"<p>v2.0 will:</p> <ul> <li>Split object association into dedicated \"Objects\" classes</li> <li>Remove mode-dependent return types (<code>track_objects</code>, <code>as_items</code>)</li> <li>Provide explicit NumPy APIs via <code>_np</code> methods (no runtime type detection)</li> <li>Simplify serialization and make object serialization explicit and opt-in</li> </ul>"},{"location":"2.0_proposal/#breaking-changes","title":"Breaking Changes","text":""},{"location":"2.0_proposal/#1-split-object-association-into-separate-classes","title":"1) Split Object Association into Separate Classes","text":""},{"location":"2.0_proposal/#current-api","title":"Current API","text":"<pre><code>qt = QuadTree(bounds, capacity, track_objects=True)   # or False\nrqt = RectQuadTree(bounds, capacity, track_objects=True)  # or False\n</code></pre>"},{"location":"2.0_proposal/#new-api","title":"New API","text":"<pre><code># High performance spatial index (no object association)\nqt = QuadTree(bounds, capacity)\nrqt = RectQuadTree(bounds, capacity)\n\n# Spatial index with Python object association\nqt_obj = QuadTreeObjects(bounds, capacity)\nrqt_obj = RectQuadTreeObjects(bounds, capacity)\n</code></pre>"},{"location":"2.0_proposal/#naming-rationale","title":"Naming rationale","text":"Class Purpose Mental model <code>QuadTree</code> Fast index for points \"store points with IDs\" <code>QuadTreeObjects</code> Points with associated Python objects \"points plus attached payloads\" <code>RectQuadTree</code> Fast index for rectangles \"store boxes with IDs\" <code>RectQuadTreeObjects</code> Rectangles with associated Python objects \"boxes plus attached payloads\""},{"location":"2.0_proposal/#why-this-change","title":"Why this change","text":"<ul> <li>Eliminates runtime branching and confusing toggles (<code>track_objects</code>, <code>as_items</code>)</li> <li>Keeps the fastest class as the default (<code>QuadTree</code>, <code>RectQuadTree</code>)</li> <li>Clear separation of capabilities and better typing</li> </ul>"},{"location":"2.0_proposal/#2-predictable-query-return-types-no-as_items","title":"2) Predictable Query Return Types (No <code>as_items</code>)","text":""},{"location":"2.0_proposal/#quadtree-no-objects","title":"<code>QuadTree</code> (no objects)","text":"<pre><code>results = qt.query(rect)  # list[tuple[int, float, float]]\n\nfor id_, x, y in results:\n    ...\n</code></pre>"},{"location":"2.0_proposal/#quadtreeobjects-objects","title":"<code>QuadTreeObjects</code> (objects)","text":"<pre><code>results = qt_obj.query(rect)  # list[PointItem]\n\nfor item in results:\n    print(item.id_, item.x, item.y, item.obj)\n\nids = qt_obj.query_ids(rect)  # list[int] fast path\n</code></pre>"},{"location":"2.0_proposal/#impact","title":"Impact","text":"<ul> <li>Remove <code>as_items</code> everywhere</li> <li>If you previously used <code>as_items=True</code>, migrate to <code>QuadTreeObjects</code></li> <li>If you previously used the default tuple output, stay on <code>QuadTree</code></li> </ul>"},{"location":"2.0_proposal/#3-explicit-numpy-methods-_np-only","title":"3) Explicit NumPy Methods (<code>_np</code>) Only","text":""},{"location":"2.0_proposal/#current-behavior-v1","title":"Current behavior (v1)","text":"<ul> <li><code>insert_many</code> accepts list or ndarray and branches at runtime</li> </ul>"},{"location":"2.0_proposal/#new-behavior-v2","title":"New behavior (v2)","text":"<pre><code>qt.insert_many([(x1, y1), (x2, y2)])  # Python sequences only\nqt.insert_many_np(xy_array)           # NumPy only\n\nqt.query(rect)                        # Python list output\nids, coords = qt.query_np(rect)        # NumPy output\n\nids, coords = qt.nearest_neighbors_np(point, k)\n</code></pre>"},{"location":"2.0_proposal/#rules","title":"Rules","text":"<ul> <li>Passing a NumPy array into a non-<code>_np</code> method raises <code>TypeError</code></li> <li><code>_np</code> methods require NumPy installed (raise <code>ImportError</code> if missing)</li> </ul>"},{"location":"2.0_proposal/#numpy-output-guarantees","title":"NumPy output guarantees","text":"<ul> <li><code>ids</code> is <code>np.uint64</code> with shape <code>(N,)</code></li> <li><code>coords</code> is <code>np.float32</code>, <code>np.float64</code>, <code>np.int32</code>, or <code>np.int64</code> matching <code>dtype</code>, shape <code>(N, 2)</code> for points and <code>(N, 4)</code> for rects</li> </ul>"},{"location":"2.0_proposal/#4-improved-insertion-api","title":"4) Improved Insertion API","text":""},{"location":"2.0_proposal/#single-insertion-with-optional-custom-id-non-objects-classes","title":"Single insertion with optional custom ID (non-Objects classes)","text":"<pre><code>id_ = qt.insert((x, y))           # auto-assigned ID\nid_ = qt.insert((x, y), id_=42)   # custom ID\n</code></pre> <p>This allows users to correlate quadtree entries with external data structures (e.g., indices into a list or dataset) without the overhead of object association.</p> <p>Warning: Mixing auto-assigned and custom IDs is dangerous. The quadtree does not track which IDs have been used. If you provide a custom ID that collides with an auto-assigned ID (or vice versa), both entries will exist in the tree with the same ID, leading to undefined behavior on deletion and update. Users who provide custom IDs are responsible for ensuring uniqueness.</p>"},{"location":"2.0_proposal/#bulk-insertion-with-insertresult","title":"Bulk insertion with <code>InsertResult</code>","text":"<pre><code>result = qt.insert_many([(x1, y1), (x2, y2)])\n\nresult.count\nresult.start_id\nresult.end_id\n</code></pre> <p>IDs are contiguous in the inserted range: <code>[start_id, ..., end_id]</code>.</p> <p>Bulk insertion does not support custom IDs. Use single <code>insert()</code> calls if you need custom IDs.</p> <p>Note: For performance, <code>insert_many()</code> and <code>insert_many_np()</code> always append new items and do not reuse IDs from the free-list created by deletions. Use single <code>insert()</code> calls to fill holes in the ID space.</p>"},{"location":"2.0_proposal/#objects-variants-support-payloads","title":"Objects variants support payloads","text":"<pre><code>qt_obj.insert((x, y), obj=my_data)\nqt_obj.insert_many(coords, objs=[obj1, obj2, ...])\n</code></pre> <p><code>QuadTreeObjects</code> does not support custom IDs because it uses dense ID allocation internally for efficient object lookup.</p>"},{"location":"2.0_proposal/#insertresult","title":"InsertResult","text":"<pre><code>@dataclass\nclass InsertResult:\n    count: int\n    start_id: int\n    end_id: int\n\n    @property\n    def ids(self):\n        return range(self.start_id, self.end_id + 1)\n</code></pre>"},{"location":"2.0_proposal/#5-deletion-semantics-and-duplicates","title":"5) Deletion Semantics (and duplicates)","text":""},{"location":"2.0_proposal/#non-objects-classes-require-coordinates","title":"Non-Objects classes require coordinates","text":"<pre><code>qt.delete(id_, x, y)\nrqt.delete(id_, min_x, min_y, max_x, max_y)\n</code></pre>"},{"location":"2.0_proposal/#objects-classes-can-delete-by-id-alone","title":"Objects classes can delete by id alone","text":"<pre><code>qt_obj.delete(id_)\nrqt_obj.delete(id_)\n</code></pre>"},{"location":"2.0_proposal/#location-based-deletion-for-objects-variants","title":"Location-based deletion for Objects variants","text":"<pre><code>qt_obj.delete_at(x, y)\n</code></pre> <p>Duplicate points: If multiple items exist at <code>(x, y)</code>, <code>delete_at(x, y)</code> deletes the lowest <code>id_</code> among matches. This is deterministic and documented.</p>"},{"location":"2.0_proposal/#object-deletion-semantics-identity-not-equality","title":"Object deletion semantics (identity, not equality)","text":"<pre><code>qt_obj.delete_by_object(obj)  # uses identity (is), deletes ALL matches\nqt_obj.delete_one_by_object(obj)  # deletes one match (lowest id_)\n</code></pre> <p>Identity-based deletion avoids surprising behavior with <code>__eq__</code>, mutability, or duplicates.</p> <p>Duplicate object handling: The same Python object can be inserted multiple times at different locations. The implementation tracks all IDs associated with each object: - <code>delete_by_object(obj)</code> deletes all items with that object (by identity) and returns the count - <code>delete_one_by_object(obj)</code> deletes exactly one item (deterministically: the one with the lowest ID) - <code>by_obj()</code> internal lookups return the item with the lowest ID (deterministic) - <code>attach()</code> correctly updates the reverse mapping when replacing objects</p>"},{"location":"2.0_proposal/#6-remove-count_items-keep-len-only","title":"6) Remove <code>count_items()</code>, keep <code>len()</code> only","text":"<pre><code>n = len(qt)\n</code></pre>"},{"location":"2.0_proposal/#7-serialization-bytes-only-dtype-encoded-objects-opt-in-and-guarded","title":"7) Serialization: bytes-only, dtype encoded, objects opt-in and guarded","text":""},{"location":"2.0_proposal/#new-api_1","title":"New API","text":"<pre><code>data = qt.to_bytes()\nqt2 = QuadTree.from_bytes(data)\n</code></pre>"},{"location":"2.0_proposal/#objects-trees","title":"Objects trees","text":"<p>Object serialization is explicit and off by default.</p> <pre><code>data = qt_obj.to_bytes(include_objects=False)      # default\ndata2 = qt_obj.to_bytes(include_objects=True)      # opt-in\n\nqt_obj2 = QuadTreeObjects.from_bytes(data2, allow_objects=True)\n</code></pre>"},{"location":"2.0_proposal/#safety-notes","title":"Safety notes","text":"<ul> <li>Loading objects from bytes uses pickle-like semantics and is unsafe for untrusted data.</li> <li><code>allow_objects</code> defaults to <code>False</code> to prevent accidental unsafe loads.</li> </ul>"},{"location":"2.0_proposal/#impact_1","title":"Impact","text":"<ul> <li>Remove <code>to_dict()</code></li> <li>Remove <code>dtype=</code> from <code>from_bytes()</code></li> <li>v2 serialization is not backward compatible with v1</li> </ul>"},{"location":"2.0_proposal/#new-features-non-breaking-additions","title":"New Features (Non-breaking additions)","text":""},{"location":"2.0_proposal/#__contains__","title":"<code>__contains__</code>","text":"<pre><code>if (10.0, 20.0) in qt:\n    ...\n</code></pre> <p>Semantics with duplicates: membership is <code>True</code> if any item exists at that coordinate.</p>"},{"location":"2.0_proposal/#iteration","title":"Iteration","text":"<pre><code>for id_, x, y in qt:\n    ...\n\nfor item in qt_obj:\n    ...\n</code></pre>"},{"location":"2.0_proposal/#moving-items-efficient-where-possible","title":"Moving items: efficient where possible","text":""},{"location":"2.0_proposal/#points","title":"Points","text":"<ul> <li><code>QuadTreeObjects.update(id_, new_x, new_y)</code> works efficiently (it knows old coords)</li> <li><code>QuadTree.update(...)</code> must include old coords to avoid hidden scans</li> </ul> <pre><code>qt.update(id_, old_x, old_y, new_x, new_y)\nqt_obj.update(id_, new_x, new_y)\n</code></pre>"},{"location":"2.0_proposal/#rectangles","title":"Rectangles","text":"<pre><code>rqt.update(id_, old_min_x, old_min_y, old_max_x, old_max_y, new_min_x, new_min_y, new_max_x, new_max_y)\nrqt_obj.update(id_, new_min_x, new_min_y, new_max_x, new_max_y)\n</code></pre> <p>This keeps performance promises intact for the non-Objects classes.</p>"},{"location":"2.0_proposal/#update_by_object-helper-objects-classes-only","title":"<code>update_by_object</code> helper (Objects classes only)","text":"<p>Objects classes provide a convenience method to update an item by finding it via its associated object (by identity):</p> <pre><code>qt_obj.update_by_object(obj, new_x, new_y)\nrqt_obj.update_by_object(obj, new_min_x, new_min_y, new_max_x, new_max_y)\n</code></pre> <p>If multiple items have the same object, updates the one with the lowest ID.</p> <p>Returns <code>True</code> if the item was found and updated, <code>False</code> otherwise.</p>"},{"location":"2.0_proposal/#migration-guide","title":"Migration Guide","text":""},{"location":"2.0_proposal/#step-1-choose-your-class","title":"Step 1: Choose your class","text":"Old usage <code>track_objects</code> New class <code>QuadTree</code> False <code>QuadTree</code> <code>QuadTree</code> True <code>QuadTreeObjects</code> <code>RectQuadTree</code> False <code>RectQuadTree</code> <code>RectQuadTree</code> True <code>RectQuadTreeObjects</code>"},{"location":"2.0_proposal/#step-2-imports","title":"Step 2: Imports","text":"<pre><code>from fastquadtree import (\n    QuadTree,\n    QuadTreeObjects,\n    RectQuadTree,\n    RectQuadTreeObjects,\n)\n</code></pre>"},{"location":"2.0_proposal/#step-3-queries","title":"Step 3: Queries","text":"Before After <code>qt.query(rect, as_items=True)</code> <code>qt_obj.query(rect)</code> <code>qt.query(rect, as_items=False)</code> <code>qt.query(rect)</code>"},{"location":"2.0_proposal/#step-4-numpy-calls","title":"Step 4: NumPy calls","text":"Before After <code>qt.insert_many(np_array)</code> <code>qt.insert_many_np(np_array)</code>"},{"location":"2.0_proposal/#step-5-insert-results","title":"Step 5: Insert results","text":"Before After <code>count = qt.insert_many(points)</code> <code>r = qt.insert_many(points); count = r.count</code> <code>n, start = qt.insert_many(pts, get_start_id=True)</code> <code>r = qt.insert_many(pts); r.count, r.start_id</code>"},{"location":"2.0_proposal/#step-6-deletion","title":"Step 6: Deletion","text":"Before After <code>qt.delete(id_, (x, y))</code> <code>qt.delete(id_, x, y)</code> <code>qt.delete_by_object(obj)</code> <code>qt_obj.delete_by_object(obj)</code>"},{"location":"2.0_proposal/#step-7-updatemove","title":"Step 7: Update/move","text":"<ul> <li>If you used object tracking, switch to <code>QuadTreeObjects.update(id_, new_x, new_y)</code></li> <li>If you did not, use <code>QuadTree.update(id_, old_x, old_y, new_x, new_y)</code></li> </ul>"},{"location":"2.0_proposal/#appendix-v20-api-reference-proposed","title":"Appendix: v2.0 API Reference (Proposed)","text":""},{"location":"2.0_proposal/#quadtree-points-no-objects","title":"QuadTree (points, no objects)","text":"<pre><code>class QuadTree:\n    def __init__(self, bounds, capacity, max_depth=None, dtype=\"f32\"): ...\n\n    # Insertion\n    def insert(self, point: tuple[float, float], id_: int | None = None) -&gt; int: ...\n    def insert_many(self, points) -&gt; InsertResult: ...\n    def insert_many_np(self, points) -&gt; InsertResult: ...\n\n    # Queries\n    def query(self, rect) -&gt; list[tuple[int, float, float]]: ...\n    def query_np(self, rect): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (N,2))\n    def nearest_neighbor(self, point) -&gt; tuple[int, float, float] | None: ...\n    def nearest_neighbor_np(self, point) -&gt; tuple[int, \"ndarray\"] | None: ...  # (id: uint64, coords: ndarray shape (2,))\n    def nearest_neighbors(self, point, k: int) -&gt; list[tuple[int, float, float]]: ...\n    def nearest_neighbors_np(self, point, k: int): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (k,2))\n\n    # Deletion\n    def delete(self, id_: int, x: float, y: float) -&gt; bool: ...\n    def clear(self) -&gt; None: ...\n\n    # Mutation\n    def update(self, id_: int, old_x: float, old_y: float, new_x: float, new_y: float) -&gt; bool: ...\n\n    # Utilities\n    def __len__(self) -&gt; int: ...\n    def __contains__(self, point: tuple[float, float]) -&gt; bool: ...\n    def __iter__(self): ...\n    def get_all_node_boundaries(self) -&gt; list[tuple]: ...\n    def get_inner_max_depth(self) -&gt; int: ...\n\n    # Serialization\n    def to_bytes(self) -&gt; bytes: ...\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; \"QuadTree\": ...\n</code></pre>"},{"location":"2.0_proposal/#quadtreeobjects-points-with-python-objects","title":"QuadTreeObjects (points with Python objects)","text":"<pre><code>class QuadTreeObjects:\n    def __init__(self, bounds, capacity, max_depth=None, dtype=\"f32\"): ...\n\n    # Insertion (no custom IDs - uses dense allocation)\n    def insert(self, point: tuple[float, float], obj=None) -&gt; int: ...\n    def insert_many(self, points, objs=None) -&gt; InsertResult: ...\n    def insert_many_np(self, points, objs=None) -&gt; InsertResult: ...\n\n    # Queries\n    def query(self, rect) -&gt; list[\"PointItem\"]: ...\n    def query_ids(self, rect) -&gt; list[int]: ...\n    def query_np(self, rect): ...  # ids, coords (coords shape (N,2), dtype matches tree)\n    def nearest_neighbor(self, point) -&gt; \"PointItem\" | None: ...\n    def nearest_neighbors(self, point, k: int) -&gt; list[\"PointItem\"]: ...\n\n    # Deletion\n    def delete(self, id_: int) -&gt; bool: ...\n    def delete_at(self, x: float, y: float) -&gt; bool: ...  # deletes lowest-id_ match\n    def delete_by_object(self, obj) -&gt; int: ...            # deletes all, returns count\n    def delete_one_by_object(self, obj) -&gt; bool: ...             # deletes one, lowest id_\n    def clear(self) -&gt; None: ...\n\n    # Object management\n    def get(self, id_: int): ...\n    def attach(self, id_: int, obj) -&gt; None: ...\n    def get_all_objects(self) -&gt; list: ...\n    def get_all_items(self) -&gt; list[\"PointItem\"]: ...\n\n    # Mutation\n    def update(self, id_: int, new_x: float, new_y: float) -&gt; bool: ...\n    def update_by_object(self, obj, new_x: float, new_y: float) -&gt; bool: ...\n\n    # Utilities\n    def __len__(self) -&gt; int: ...\n    def __contains__(self, point: tuple[float, float]) -&gt; bool: ...\n    def __iter__(self): ...\n\n    # Serialization\n    def to_bytes(self, include_objects: bool = False) -&gt; bytes: ...\n    @classmethod\n    def from_bytes(cls, data: bytes, allow_objects: bool = False) -&gt; \"QuadTreeObjects\": ...\n</code></pre>"},{"location":"2.0_proposal/#rectquadtree-rectangles-no-objects","title":"RectQuadTree (rectangles, no objects)","text":"<pre><code>class RectQuadTree:\n    def __init__(self, bounds, capacity, max_depth=None, dtype=\"f32\"): ...\n\n    # Insertion\n    def insert(self, rect: tuple[float, float, float, float], id_: int | None = None) -&gt; int: ...\n    def insert_many(self, rects) -&gt; InsertResult: ...\n    def insert_many_np(self, rects) -&gt; InsertResult: ...\n\n    # Queries\n    def query(self, rect) -&gt; list[tuple[int, float, float, float, float]]: ...\n    def query_np(self, rect): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (N,4))\n    def nearest_neighbor(self, point) -&gt; tuple[int, float, float, float, float] | None: ...\n    def nearest_neighbor_np(self, point) -&gt; tuple[int, \"ndarray\"] | None: ...  # (id: uint64, coords: ndarray shape (4,))\n    def nearest_neighbors(self, point, k: int) -&gt; list[tuple[int, float, float, float, float]]: ...\n    def nearest_neighbors_np(self, point, k: int): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (k,4))\n\n    # Deletion\n    def delete(self, id_: int, min_x: float, min_y: float, max_x: float, max_y: float) -&gt; bool: ...\n    def clear(self) -&gt; None: ...\n\n    # Mutation\n    def update(self, id_: int, old_min_x: float, old_min_y: float, old_max_x: float, old_max_y: float,\n               new_min_x: float, new_min_y: float, new_max_x: float, new_max_y: float) -&gt; bool: ...\n\n    # Utilities\n    def __len__(self) -&gt; int: ...\n    def __contains__(self, rect: tuple[float, float, float, float]) -&gt; bool: ...\n    def __iter__(self): ...\n    def get_all_node_boundaries(self) -&gt; list[tuple]: ...\n    def get_inner_max_depth(self) -&gt; int: ...\n\n    # Serialization\n    def to_bytes(self) -&gt; bytes: ...\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; \"RectQuadTree\": ...\n</code></pre>"},{"location":"2.0_proposal/#rectquadtreeobjects-rectangles-with-python-objects","title":"RectQuadTreeObjects (rectangles with Python objects)","text":"<pre><code>class RectQuadTreeObjects:\n    def __init__(self, bounds, capacity, max_depth=None, dtype=\"f32\"): ...\n\n    # Insertion (no custom IDs - uses dense allocation)\n    def insert(self, rect: tuple[float, float, float, float], obj=None) -&gt; int: ...\n    def insert_many(self, rects, objs=None) -&gt; InsertResult: ...\n    def insert_many_np(self, rects, objs=None) -&gt; InsertResult: ...\n\n    # Queries\n    def query(self, rect) -&gt; list[\"RectItem\"]: ...\n    def query_ids(self, rect) -&gt; list[int]: ...\n    def query_np(self, rect): ...  # ids, coords (coords shape (N,4), dtype matches tree)\n    def nearest_neighbor(self, point) -&gt; \"RectItem\" | None: ...\n    def nearest_neighbors(self, point, k: int) -&gt; list[\"RectItem\"]: ...\n\n    # Deletion\n    def delete(self, id_: int) -&gt; bool: ...\n    def delete_at(self, min_x: float, min_y: float, max_x: float, max_y: float) -&gt; bool: ...\n    def delete_by_object(self, obj) -&gt; int: ...\n    def delete_one_by_object(self, obj) -&gt; bool: ...\n    def clear(self) -&gt; None: ...\n\n    # Object management\n    def get(self, id_: int): ...\n    def attach(self, id_: int, obj) -&gt; None: ...\n    def get_all_objects(self) -&gt; list: ...\n    def get_all_items(self) -&gt; list[\"RectItem\"]: ...\n\n    # Mutation\n    def update(self, id_: int, new_min_x: float, new_min_y: float, new_max_x: float, new_max_y: float) -&gt; bool: ...\n    def update_by_object(self, obj, new_min_x: float, new_min_y: float, new_max_x: float, new_max_y: float) -&gt; bool: ...\n\n    # Utilities\n    def __len__(self) -&gt; int: ...\n    def __contains__(self, rect: tuple[float, float, float, float]) -&gt; bool: ...\n    def __iter__(self): ...\n\n    # Serialization\n    def to_bytes(self, include_objects: bool = False) -&gt; bytes: ...\n    @classmethod\n    def from_bytes(cls, data: bytes, allow_objects: bool = False) -&gt; \"RectQuadTreeObjects\": ...\n</code></pre>"},{"location":"2.0_proposal/#data-classes","title":"Data Classes","text":"<pre><code>@dataclass\nclass InsertResult:\n    count: int\n    start_id: int\n    end_id: int\n\n    @property\n    def ids(self) -&gt; range:\n        return range(self.start_id, self.end_id + 1)\n</code></pre>"},{"location":"2.0_proposal/#implementation-details","title":"Implementation Details","text":""},{"location":"2.0_proposal/#objstore-efficient-object-tracking","title":"ObjStore: Efficient Object Tracking","text":"<p>The <code>ObjStore</code> class (used internally by <code>QuadTreeObjects</code> and <code>RectQuadTreeObjects</code>) maintains a bidirectional mapping between IDs and Python objects:</p> <p>Storage: - <code>_arr[id]</code> \u2192 Item or None (dense array) - <code>_objs[id]</code> \u2192 Python object or None (parallel array) - <code>_obj_to_ids</code> \u2192 <code>dict[int, set[int]]</code> reverse map from <code>id(obj)</code> to all associated IDs - <code>_free</code> \u2192 LIFO free-list of reusable IDs</p> <p>Key behaviors: 1. Multiple insertions of the same object are tracked: When the same Python object is inserted multiple times at different locations, all IDs are stored in a set 2. Deterministic lookup: <code>by_obj(obj)</code> returns the item with the lowest ID (using <code>min(ids)</code>) 3. Efficient deletion: <code>delete_by_object()</code> retrieves all IDs via <code>by_obj_all()</code> and deletes each one 4. Safe object replacement: <code>attach(id, new_obj)</code> correctly removes the old object's ID from the reverse map, preventing corruption</p> <p>Performance characteristics: - <code>add()</code>: O(1) average (set insertion) - <code>by_obj()</code>: O(k) where k = number of duplicates (typically small; <code>min()</code> on small sets is fast) - <code>by_obj_all()</code>: O(k log k) for sorting - <code>pop_id()</code>: O(1) average (set removal) - Memory overhead: ~8 bytes per duplicate object insertion (set entry)</p> <p>This design ensures correct semantics for duplicate objects while maintaining excellent performance for the common case (no duplicates).</p>"},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#query-insert-performance","title":"Query + Insert Performance","text":"<p>These benchmarks compare the total time to execute a set number of  queries and inserts across various Python spatial index libraries. Quadtrees are the focus of the benchmark, but Rtrees are included for reference.</p> <p> </p>"},{"location":"benchmark/#summary-largest-dataset-pyqtree-baseline","title":"Summary (largest dataset, PyQtree baseline)","text":"<ul> <li>Points: 500,000, Queries: 500</li> <li>Fastest total: fastquadtree at 0.068 s</li> </ul> Library Build (s) Query (s) Total (s) Speed vs PyQtree fastquadtree (np)<sup>1</sup> 0.052 0.017 0.068 42.52\u00d7 fastquadtree<sup>2</sup> 0.054 0.231 0.285 10.20\u00d7 Shapely STRtree<sup>3</sup> 0.200 0.110 0.309 9.40\u00d7 fastquadtree (obj tracking)<sup>4</sup> 0.263 0.093 0.356 8.17\u00d7 nontree-QuadTree 0.826 0.844 1.670 1.74\u00d7 Rtree 1.805 0.546 2.351 1.24\u00d7 e-pyquadtree 1.530 0.941 2.471 1.18\u00d7 quads 1.907 0.759 2.667 1.09\u00d7 PyQtree 2.495 0.414 2.909 1.00\u00d7"},{"location":"benchmark/#benchmark-configuration","title":"Benchmark Configuration","text":"Parameter Value Bounds (0, 0, 1000, 1000) Max points per node 128 Max depth 16 Queries per experiment 500 <p>Fastquadtree is using query_np to return Numpy arrays rather than typical Python objects</p>"},{"location":"benchmark/#native-vs-shim","title":"Native vs Shim","text":""},{"location":"benchmark/#configuration","title":"Configuration","text":"<ul> <li>Points: 500,000</li> <li>Queries: 500</li> <li>Repeats: 3</li> </ul>"},{"location":"benchmark/#results","title":"Results","text":"Variant Build Query Total Native 0.140 2.364 2.504 Native (ID-only query) 0.136 0.434 0.570 QuadTree (no objects) 0.179 2.210 2.389 QuadTree insert_many (no objects) 0.058 2.085 2.143 QuadTreeObjects 0.599 0.732 1.331 QuadTree (numpy, no objects) 0.032 0.102 0.134"},{"location":"benchmark/#summary","title":"Summary","text":"<ul> <li> <p>The Python shim (QuadTree) is 0.954x slower than the native engine due to Python overhead.</p> </li> <li> <p>NumPy points are the fastest path: build is 5.536x faster than the list path and queries are 21.733x faster,   for a 17.822x total speedup vs the list path.</p> </li> <li> <p>QuadTreeObjects adds object association overhead. Build time increases significantly, query time much faster.</p> </li> </ul>"},{"location":"benchmark/#pyqtree-drop-in-shim-performance-gains","title":"pyqtree drop-in shim performance gains","text":""},{"location":"benchmark/#configuration_1","title":"Configuration","text":"<ul> <li>Points: 500,000</li> <li>Queries: 500</li> <li>Repeats: 3</li> </ul>"},{"location":"benchmark/#results_1","title":"Results","text":"Variant Build Query Total pyqtree (fastquadtree) 0.326 0.801 1.127 pyqtree (original) 2.111 9.536 11.647"},{"location":"benchmark/#summary_1","title":"Summary","text":"<p>If you directly replace pyqtree with the drop-in <code>fastquadtree.pyqtree.Index</code> shim, you get a build time of 0.326s and query time of 0.801s. This is a total speedup of 10.333x compared to the original pyqtree and requires no code changes.</p>"},{"location":"benchmark/#numpy-bulk-insert-vs-python-list-insert","title":"NumPy Bulk Insert vs Python List Insert","text":""},{"location":"benchmark/#configuration_2","title":"Configuration","text":"<ul> <li>Points: 500,000</li> <li>Repeats: 5</li> <li>Dtype: float32</li> </ul> <p>Results (median of repeats)</p> Variant Build time NumPy array direct 42.3 ms Python list insert only 58.2 ms Python list including conversion 573.4 ms <p>Key:  </p> <ul> <li>NumPy array direct: Using the <code>insert_many_np</code> method with a NumPy array of shape (N, 2).  </li> <li>Python list insert only: Using the <code>insert_many</code> method with a Python list of tuples.  </li> <li>Python list including conversion: Time taken to convert a NumPy array to a Python list of tuples, then inserting.  </li> </ul>"},{"location":"benchmark/#summary_2","title":"Summary","text":"<p>If your data is already in a NumPy array, using the <code>insert_many_np</code> method directly with the array is significantly faster than converting to a Python list first.</p>"},{"location":"benchmark/#serialization-vs-rebuild","title":"Serialization vs Rebuild","text":""},{"location":"benchmark/#configuration_3","title":"Configuration","text":"<ul> <li>Points: 1,000,000</li> <li>Capacity: 64</li> <li>Max depth: 10</li> <li>Repeats: 7</li> </ul>"},{"location":"benchmark/#results_2","title":"Results","text":"Variant Mean (s) Stdev (s) Serialize to bytes 0.021356 0.000937 Rebuild from points 0.106783 0.011430 Rebuild from bytes 0.021754 0.001687 Rebuild from file 0.024887 0.001846"},{"location":"benchmark/#summary_3","title":"Summary","text":"<ul> <li>Rebuild from bytes is 4.908747x faster than reinserting points.</li> <li>Rebuild from file is 4.290712x faster than reinserting points.</li> <li>Serialized blob size is 13,770,328 bytes.</li> </ul>"},{"location":"benchmark/#system-info","title":"System Info","text":"<ul> <li>OS: CachyOS 6.18.5-2-cachyos x86_64</li> <li>Python: CPython 3.14.2</li> <li>CPU: AMD Ryzen 7 3700X 8-Core Processor (16 threads)</li> <li>Memory: 31.3 GB</li> <li>GPU: NVIDIA GeForce RTX 5070 (11.9 GB)</li> </ul>"},{"location":"benchmark/#running-benchmarks","title":"Running Benchmarks","text":"<p>To run the benchmarks yourself, first install the dependencies with uv:</p> <p>uv installation instructions</p> <pre><code>git clone https://github.com/Elan456/fastquadtree.git\ncd fastquadtree\n</code></pre> <p>uv will manage a virtual environment for you. To set it up, run:</p> <pre><code>uv sync --group benchmark \n</code></pre> <p>Then run whichever benchmark scripts you want:</p> <pre><code>uv run python benchmarks/cross_library_bench.py\nuv run python benchmarks/benchmark_native_vs_shim.py \nuv run python benchmarks/benchmark_np_vs_list.py \nuv run python benchmarks/benchmark_serialization_vs_rebuild.py\n</code></pre> <p>Check the CLI arguments for the cross-library benchmark in <code>benchmarks/quadtree_bench/main.py</code>.</p> <ol> <li> <p>Uses <code>query_np</code> for Numpy array return values rather than Python lists.\u00a0\u21a9</p> </li> <li> <p>Uses standard <code>query</code> method returning Python lists.\u00a0\u21a9</p> </li> <li> <p>Uses Shapely STRtree with Numpy array points and returns.\u00a0\u21a9</p> </li> <li> <p>Uses QuadTreeObjects with object association.\u00a0\u21a9</p> </li> </ol>"},{"location":"future_features/","title":"Future Features","text":"<p>Below are a list of features that may be added to future versions of this project.  If you really want any of these features, please let us know by opening an issue.</p> <p>If you have any suggestions or would like to contribute, please feel free to open an issue or a pull request.</p> <p>The features will likely be implemented in the order they are listed below, but this is not guaranteed.</p>"},{"location":"future_features/#planned-features","title":"\ud83d\udea7 Planned Features","text":""},{"location":"future_features/#1-rust-core-published-to-cratesio","title":"1. Rust core published to crates.io","text":"<p>Currently, the Rust code is only available via Git dependency. By publishing the Rust core to crates.io, we can make it easier for Rust developers to use the quadtree in their projects. This will also allow us to use semantic versioning for the Rust crate, making it easier to manage dependencies.</p>"},{"location":"future_features/#2-knn-with-criteria-function","title":"2. KNN with criteria function","text":"<p>Currently, KNN only supports finding the nearest neighbors based on euclidean distance. By adding a criteria function, we could allow users to define custom criteria for finding neighbors by passing a function that  takes in a point and returns a score. The KNN algorithm would then use this score to determine the nearest neighbors.</p>"},{"location":"future_features/#3-circle-support","title":"3. Circle support","text":"<p>Currently, we support points and rectangles in two separate quadtrees. For example, in the ball-pit demo, we use a point quadtree, but then query a larger area to account for the radius of the balls. With a circle quadtree, we could directly insert circles and perform circle-circle collision detection.</p> <p>A good alternative is to use the rectangle quadtree and insert the minimum bounding rectangles of the circles.</p>"},{"location":"future_features/#completed-planned-features","title":"\u2705 Completed Planned Features","text":"<p>Once a feature from above is completed, it will be moved to this section.</p>"},{"location":"future_features/#knn-in-rectangle-quadtree-150","title":"KNN in rectangle quadtree (1.5.0)","text":"<p>Currently, KNN is only supported in the point quadtree. By adding KNN support to the rectangle quadtree, we could allow users to find the nearest rectangles to a given point. This would be to the nearest edge of the rectangle, adding complexity to the algorithm. However, it will allow for really quick collision detection between a point and a set of rectangles as the point can just do robust-collision handling with the nearest rectangles.</p>"},{"location":"future_features/#numpy-queries-140","title":"Numpy Queries (1.4.0)","text":"<p>To improve performance when querying, we add support to have your result returned in a pre-allocated Numpy array. This saves on allocation time and allows for better memory management. A lot of time is wasted on creating Python objects, so if a Numpy array is acceptable for your use case, this will be much faster.</p>"},{"location":"future_features/#configurable-quadtree-coordinate-type-130","title":"Configurable Quadtree Coordinate Type (1.3.0)","text":"<p>Currently, the point quadtree only uses f32 for point coordinates, limiting precision in favor of better performance. To make the quadtree more flexible, we could allow users to specify the coordinate type (e.g., f64, i32, etc.) when creating a quadtree. The f32 will remain the default, but users will be able to specify a different type if needed.</p> <p>If the type cannot be made truly generic, then only the following types would be supported: f32, f64, i32, i64</p>"},{"location":"future_features/#quadtree-serialization-120","title":"Quadtree serialization (1.2.0)","text":"<p>By serializing the quadtree, we can save its state to a file and load it later. This will allow us to persist the quadtree structure and data across sessions. For example, you could pre build a quadtree with all the walls in your video game level, serialize it to a file, and then load it when the game starts. This will heavily reduce the game load time since you won't have to rebuild the quadtree from scratch every time.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Meet fastquadtree \u2014 a Rust powered spatial index for Python</p> <p>TLDR: create a tree, insert points, insert boxes, query ranges or nearest neighbors.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install fastquadtree\n</code></pre>"},{"location":"quickstart/#30-second-demo","title":"30-second demo","text":"<pre><code>from fastquadtree import QuadTree\n\n# 1) Make a tree that covers your world\nqt = QuadTree(bounds=(0, 0, 1000, 1000), capacity=20)\n\n# 2) Add some stuff (a, b, and c are auto-generated ids)\na = qt.insert((10, 10))\nb = qt.insert((200, 300))\nc = qt.insert((999, 500))\n\n# 3) Ask spatial questions\nprint(\"Range hits:\", qt.query((0, 0, 250, 350)))  # -&gt; [(id, x, y), ...]\n\nprint(\"Nearest to (210, 310):\", qt.nearest_neighbor((210, 310)))\n# -&gt; (1, 200.0, 300.0)\n\nprint(\"Top 3 near (210, 310):\", qt.nearest_neighbors((210, 310), 3))\n# -&gt; [(1, 200.0, 300.0), (0, 10.0, 10.0), (2, 999.0, 500.0)]\n\n# 4) Delete by id and exact location\nprint(\"Deleted:\", qt.delete(b, 200, 300))\nprint(\"Count:\", len(qt))  # -&gt; 2\n\n# 5) Update position by id and exact location\nsuccess = qt.update(a, 10, 10, 35, 35)  # Move point a to (35, 35)\nprint(\"Update success:\", success)  # -&gt; True\n</code></pre>"},{"location":"quickstart/#range-queries-that-feel-natural","title":"Range queries that feel natural","text":"<pre><code># Think of it like a camera frustum in 2D\nviewport = (100, 200, 400, 600)\nfor id_, x, y in qt.query(viewport):\n    print(f\"Visible: id={id_} at ({x:.1f}, {y:.1f})\")\n</code></pre> <p>Use this for viewport culling, collision broad-phase, spatial filtering, and quick \u201cwhat is inside this box\u201d checks.</p>"},{"location":"quickstart/#nearest-neighbor-for-snapping-and-picking","title":"Nearest neighbor for snapping and picking","text":"<pre><code>cursor = (212, 305)\nhit = qt.nearest_neighbor(cursor)\nif hit:\n    id_, x, y = hit\n    print(f\"Closest to cursor is id={id_} at ({x:.1f}, {y:.1f})\")\n</code></pre> <p>Need more than one neighbor</p> <pre><code>for id_, x, y in qt.nearest_neighbors(cursor, k=5):\n    print(id_, x, y)\n</code></pre>"},{"location":"quickstart/#track-python-objects-when-you-need-them","title":"Track Python objects when you need them","text":"<p>Use <code>QuadTreeObjects</code> to bind your own objects to spatial coordinates. Object lookups for deletion are O(1).</p> <pre><code>from fastquadtree import QuadTreeObjects\n\nqt = QuadTreeObjects((0, 0, 1000, 1000), capacity=16)\n\nplayer = {\"name\": \"Alice\", \"hp\": 100}\nenemy  = {\"name\": \"Boblin\", \"hp\": 60}\n\npid = qt.insert((50, 50), obj=player)\neid = qt.insert((80, 60), obj=enemy)\n\n# Query returns Item objects with both coordinates and the stored object\nitems = qt.query((0, 0, 200, 200))\nfor item in items:\n    print(item.id_, item.x, item.y, item.obj)\n\n# Remove by object identity (returns deletion count)\ndeleted = qt.delete_by_object(player)  # 1\n</code></pre> <p>Tip: Use <code>QuadTree</code> instead of <code>QuadTreeObjects</code> for max speed when you do not need object tracking.</p>"},{"location":"quickstart/#reset-between-runs-without-breaking-references","title":"Reset between runs without breaking references","text":"<p>Keep the same <code>QuadTree</code> instance alive for UIs or game loops. Wipe contents and optionally reset ids.</p> <pre><code>qt.clear()  # tree is empty, auto ids start again at 0, all objects forgotten\n</code></pre>"},{"location":"quickstart/#tiny-benchmark-sketch","title":"Tiny benchmark sketch","text":"<pre><code>import random, time\nfrom fastquadtree import QuadTree\n\nN = 200_000\npts = [(random.random()*1000, random.random()*1000) for _ in range(N)]\nqt = QuadTree((0, 0, 1000, 1000), capacity=32)\n\nt0 = time.perf_counter()\nqt.insert_many(pts)\nt1 = time.perf_counter()\n\nhits = qt.query((250, 250, 750, 750))\nt2 = time.perf_counter()\n\nprint(f\"Build: {(t1-t0):.3f}s  Query: {(t2-t1):.3f}s  Hits: {len(hits)}\")\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common patterns","text":"<ul> <li>Use <code>capacity</code> 8 to 64 for most workloads   If data is highly skewed, set a <code>max_depth</code> to avoid very deep trees.</li> <li>Use <code>clear()</code> to reset when most points are moving rather than deleting and reinserting.</li> <li>Use <code>insert_many()</code> to bulk load a large batch of points at once.</li> </ul>"},{"location":"runnables/","title":"Runnable Examples","text":"<p>After cloning the repository, you can run the following examples to see how fastquadtree works in practice.</p>"},{"location":"runnables/#environment-setup","title":"Environment Setup","text":""},{"location":"runnables/#clone-the-repo","title":"Clone the repo","text":"<pre><code>git clone https://github.com/Elan456/fastquadtree.git\ncd fastquadtree\n</code></pre>"},{"location":"runnables/#create-and-activate-a-virtual-environment-install-dependencies-uv","title":"Create and activate a virtual environment, install dependencies (uv)","text":"<p>uv installation instructions</p> <p>uv will manage a virtual environment for you. To set it up, run:</p> <pre><code>uv sync --group interactive \n</code></pre>"},{"location":"runnables/#1-interactive-demo","title":"1. Interactive demo","text":"<ul> <li>Add and delete boids with mouse clicks</li> <li>Visualize KNN and range queries</li> </ul> <p>The interactive demo is a great way to see how fastquadtree works in practice. You can see how the quadtree subdivides as you add points, and validate the accuracy of the queries visually. By pressing 1, you can visualize the KNN query for each boid. </p> <pre><code>uv run python interactive/interactive_v2.py\n</code></pre> <p></p>"},{"location":"runnables/#15-interactive-demo-with-rectangles","title":"1.5 Interactive Demo with Rectangles","text":"<ul> <li>Similar to the above demo, but uses rectangles instead of points</li> <li>If the rectangles intersect at all with the query area, they will be highlighted in red</li> </ul> <p>If you are creating a game or simulation environment where entities have bounding boxes, you can use the rectangular quadtree to quickly check which entities are intersecting with another. </p> <pre><code>uv run python interactive/interactive_v2_rect.py\n</code></pre> <p></p>"},{"location":"runnables/#2-ball-pit","title":"2. Ball Pit","text":"<ul> <li>Spawn balls in a pit with physics-based collisions</li> <li>Easily switch between brute force and quadtree collision detection to see the performance difference</li> </ul> <p>The ball pit demo shows how quadtrees offer massive performance improvements for collision detection. Rectangular queries are used to find potential collisions, and then precise circle-circle collision checks are performed.</p> <pre><code>uv run python interactive/ballpit.py\n</code></pre> <p></p>"},{"location":"rust_usage/","title":"Using <code>fastquadtree</code> directly from Rust (no Python)","text":"<p><code>fastquadtree</code> is primarily a Python package on PyPI, but you can also utilize its Rust implementation directly in your Rust projects.</p> <p>Right now the easiest way to consume it from Rust is via a Git dependency (crates.io publishing may come later).</p>"},{"location":"rust_usage/#add-the-dependency","title":"Add the dependency","text":"<p>In your project\u2019s <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nfastquadtree = { git = \"https://github.com/Elan456/fastquadtree\" }\n</code></pre> <p>Then build normally:</p> <pre><code>cargo build\n</code></pre>"},{"location":"rust_usage/#minimal-example","title":"Minimal example","text":"<p>Create <code>src/main.rs</code>:</p> <pre><code>use fastquadtree::{Point, Rect, Item, QuadTree};\n\nfn main() {\n    let boundary: Rect&lt;f32&gt; = Rect {\n        min_x: 0.0,\n        min_y: 0.0,\n        max_x: 100.0,\n        max_y: 100.0,\n    };\n\n    // QuadTree::new(boundary, capacity, max_depth)\n    let mut qt: QuadTree&lt;f32&gt; = QuadTree::new(boundary, 16, 4);\n\n    let item: Item&lt;f32&gt; = Item {\n        id: 1,\n        point: Point { x: 10.0, y: 10.0 },\n    };\n\n    qt.insert(item);\n\n    let range: Rect&lt;f32&gt; = Rect {\n        min_x: 5.0,\n        min_y: 5.0,\n        max_x: 15.0,\n        max_y: 15.0,\n    };\n\n    let found_items = qt.query(range);\n    println!(\"Found items: {:?}\", found_items);\n}\n</code></pre> <p>Run it:</p> <pre><code>cargo run\n</code></pre>"},{"location":"rust_usage/#notes","title":"Notes","text":"<ul> <li>This uses the Rust \u201ccore\u201d types directly: <code>QuadTree</code>, <code>RectQuadTree</code>, <code>Rect</code>, <code>Point</code>, <code>Item</code>.</li> <li>You can find their implementations in the Rust source code</li> <li>The crate currently includes Python-related dependencies because it is also used to build the PyPI module. This is expected for now.</li> <li>In the future, dependency size will likely improve via Cargo feature flags or a split between a pure Rust <code>fastquadtree-core</code> crate and a Python wrapper crate.</li> <li>The semantic versioning of fastquadtree for PyPi is currently tied to the Python API, so breaking changes to the Rust core may not always align with major version bumps. Be sure to check the changelog for any breaking changes when updating.</li> </ul>"},{"location":"rust_usage/#pinning-to-a-specific-commit","title":"Pinning to a specific commit","text":"<p>recommended for reproducibility</p> <p>If you want your build to be fully reproducible, pin the dependency to a commit:</p> <pre><code>[dependencies]\nfastquadtree = { git = \"https://github.com/Elan456/fastquadtree\", rev = \"&lt;commit-sha&gt;\" }\n</code></pre> <p>(Replace <code>&lt;commit-sha&gt;</code> with the commit you want to lock to.)</p>"},{"location":"api/insert_result/","title":"fastquadtree.InsertResult","text":"<p>Result returned from bulk insertion operations.</p> <p>This dataclass contains information about items inserted by <code>insert_many</code> or <code>insert_many_np</code> methods, including the total count and the contiguous range of auto-assigned IDs.</p> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>Number of items successfully inserted.</p> <code>start_id</code> <code>int</code> <p>First ID in the contiguous ID range.</p> <code>end_id</code> <code>int</code> <p>Last ID in the contiguous ID range (inclusive).</p> Example <pre><code>result = qt.insert_many([(1.0, 2.0), (3.0, 4.0), (5.0, 6.0)])\nprint(f\"Inserted {result.count} items\")\nprint(f\"IDs: {list(result.ids)}\")  # [0, 1, 2]\n</code></pre>"},{"location":"api/insert_result/#fastquadtree.InsertResult.count","title":"<code>count</code>  <code>instance-attribute</code>","text":""},{"location":"api/insert_result/#fastquadtree.InsertResult.start_id","title":"<code>start_id</code>  <code>instance-attribute</code>","text":""},{"location":"api/insert_result/#fastquadtree.InsertResult.end_id","title":"<code>end_id</code>  <code>instance-attribute</code>","text":""},{"location":"api/insert_result/#fastquadtree.InsertResult.ids","title":"<code>ids</code>  <code>property</code>","text":"<p>Return a range object representing all inserted IDs.</p> <p>Returns:</p> Type Description <code>range</code> <p>Range from start_id to end_id (inclusive).</p>"},{"location":"api/item/","title":"fastquadtree.Item","text":"<p>               Bases: <code>Generic[G]</code></p> <p>Generic container for quadtree index entries.</p> <p>This class provides a lightweight wrapper around spatial index entries, containing an ID, geometry, and optional associated Python object.</p> <p>Attributes:</p> Name Type Description <code>id_</code> <code>int</code> <p>Integer identifier for this entry.</p> <code>geom</code> <code>G</code> <p>Geometry data (Point or Bounds depending on tree type).</p> <code>obj</code> <code>Any</code> <p>Associated Python object, or None if not set.</p>"},{"location":"api/item/#fastquadtree.Item.id_","title":"<code>id_ = id_</code>  <code>instance-attribute</code>","text":""},{"location":"api/item/#fastquadtree.Item.geom","title":"<code>geom = geom</code>  <code>instance-attribute</code>","text":""},{"location":"api/item/#fastquadtree.Item.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":""},{"location":"api/item/#fastquadtree.Item.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the item to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with 'id', 'geom', and 'obj' keys.</p>"},{"location":"api/item/#fastquadtree.Item.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize an item from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'id', 'geom', and 'obj' keys.</p> required <p>Returns:</p> Type Description <code>Item</code> <p>Item instance populated with the deserialized data.</p>"},{"location":"api/point_item/","title":"fastquadtree.PointItem","text":"<p>               Bases: <code>Item[Point]</code></p> <p>Specialized item container for point geometries.</p> <p>This subclass of Item adds convenient x and y attributes for direct access to point coordinates.</p> <p>Attributes:</p> Name Type Description <code>id_</code> <code>int</code> <p>Integer identifier.</p> <code>geom</code> <code>G</code> <p>Point geometry as (x, y) tuple.</p> <code>obj</code> <code>Any</code> <p>Associated Python object, or None if not set.</p> <code>x</code> <code>Any</code> <p>X coordinate (convenience accessor).</p> <code>y</code> <code>Any</code> <p>Y coordinate (convenience accessor).</p>"},{"location":"api/point_item/#fastquadtree.PointItem.id_","title":"<code>id_ = id_</code>  <code>instance-attribute</code>","text":""},{"location":"api/point_item/#fastquadtree.PointItem.geom","title":"<code>geom = geom</code>  <code>instance-attribute</code>","text":""},{"location":"api/point_item/#fastquadtree.PointItem.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":""},{"location":"api/point_item/#fastquadtree.PointItem.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the item to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with 'id', 'geom', and 'obj' keys.</p>"},{"location":"api/point_item/#fastquadtree.PointItem.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize an item from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'id', 'geom', and 'obj' keys.</p> required <p>Returns:</p> Type Description <code>Item</code> <p>Item instance populated with the deserialized data.</p>"},{"location":"api/pyqtree/","title":"fastquadtree.pyqtree.Index","text":"<p>Pyqtree-compatible spatial index with improved performance.</p> <p>This class provides the same interface as pyqtree.Index but is backed by a high-performance Rust implementation. Based on benchmarks, this provides an overall performance boost of approximately 10x compared to the original pure-Python implementation.</p> <p>For new projects not requiring pyqtree compatibility, consider using <code>RectQuadTreeObjects</code> for more control and better performance.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Iterable[SupportsFloat] | None</code> <p>Coordinate system bounding box as (xmin, ymin, xmax, ymax).</p> <code>None</code> <code>x</code> <code>float | int | None</code> <p>X center coordinate (alternative to bbox).</p> <code>None</code> <code>y</code> <code>float | int | None</code> <p>Y center coordinate (alternative to bbox).</p> <code>None</code> <code>width</code> <code>float | int | None</code> <p>Width from center (alternative to bbox).</p> <code>None</code> <code>height</code> <code>float | int | None</code> <p>Height from center (alternative to bbox).</p> <code>None</code> <code>max_items</code> <code>int</code> <p>Maximum items per quad before splitting (default: 10).</p> <code>MAX_ITEMS</code> <code>max_depth</code> <code>int</code> <p>Maximum nesting levels (default: 20).</p> <code>MAX_DEPTH</code> Note <p>Either <code>bbox</code> or all of (<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>) must be provided.</p> Example <pre><code>from fastquadtree.pyqtree import Index\n\nspindex = Index(bbox=(0, 0, 100, 100))\nspindex.insert('duck', (50, 30, 53, 60))\nspindex.insert('cookie', (10, 20, 15, 25))\nspindex.insert('python', (40, 50, 95, 90))\nresults = spindex.intersect((51, 51, 86, 86))\nprint(sorted(results))  # ['duck', 'python']\n</code></pre> <p>Initialize the spatial index.</p> <p>Specify either a bounding box or center point with dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Iterable[SupportsFloat] | None</code> <p>Bounding box as (xmin, ymin, xmax, ymax).</p> <code>None</code> <code>x</code> <code>float | int | None</code> <p>X center coordinate (alternative to bbox).</p> <code>None</code> <code>y</code> <code>float | int | None</code> <p>Y center coordinate (alternative to bbox).</p> <code>None</code> <code>width</code> <code>float | int | None</code> <p>Distance from x center to edges (alternative to bbox).</p> <code>None</code> <code>height</code> <code>float | int | None</code> <p>Distance from y center to edges (alternative to bbox).</p> <code>None</code> <code>max_items</code> <code>int</code> <p>Maximum items per quad before splitting (default: 10).</p> <code>MAX_ITEMS</code> <code>max_depth</code> <code>int</code> <p>Maximum nesting levels (default: 20).</p> <code>MAX_DEPTH</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither bbox nor (x, y, width, height) are provided.</p>"},{"location":"api/pyqtree/#fastquadtree.pyqtree.Index.insert","title":"<code>insert(item, bbox)</code>","text":"<p>Insert an item with its bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>Item to insert (will be returned by intersect queries).</p> required <code>bbox</code> <code>Iterable[SupportsFloat]</code> <p>Spatial bounding box as (xmin, ymin, xmax, ymax).</p> required"},{"location":"api/pyqtree/#fastquadtree.pyqtree.Index.remove","title":"<code>remove(item, bbox)</code>","text":"<p>Remove an item from the index.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>Item to remove (must match the inserted item).</p> required <code>bbox</code> <code>Iterable[SupportsFloat]</code> <p>Bounding box as (xmin, ymin, xmax, ymax) (must match insertion).</p> required Note <p>Both parameters must exactly match those used during insertion.</p>"},{"location":"api/pyqtree/#fastquadtree.pyqtree.Index.intersect","title":"<code>intersect(bbox)</code>","text":"<p>Query items that intersect with a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Iterable[SupportsFloat]</code> <p>Query bounding box as (xmin, ymin, xmax, ymax).</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of items whose bounding boxes intersect the query box.</p>"},{"location":"api/quadtree/","title":"fastquadtree.QuadTree","text":"<p>A spatial index for 2D points without object association.</p> <p>Parameter Name Clarification</p> <p>In the inherited methods below, the parameter <code>geom</code> refers to a point coordinate tuple <code>(x, y)</code>.</p> <p>For example:</p> <ul> <li><code>insert(geom)</code> means <code>insert((x, y))</code></li> <li><code>insert_many(geoms)</code> means <code>insert_many([(x1, y1), (x2, y2), ...])</code></li> </ul> <p>               Bases: <code>_BaseQuadTree[Point]</code></p> <p>Spatial index for 2D points without object association.</p> <p>This class provides fast spatial indexing for points using integer IDs that you can correlate with external data structures. For automatic object association, see <code>QuadTreeObjects</code>.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Bounds</code> <p>World bounds as (min_x, min_y, max_x, max_y).</p> required <code>capacity</code> <code>int</code> <p>Maximum points per node before splitting.</p> required <code>max_depth</code> <code>int | None</code> <p>Optional maximum tree depth (uses engine default if not specified).</p> <code>None</code> <code>dtype</code> <code>QuadTreeDType</code> <p>Coordinate data type ('f32', 'f64', 'i32', 'i64'). Default: 'f32'.</p> <code>'f32'</code> Performance <ul> <li>Inserts: O(log n) average</li> <li>Queries: O(log n + k) average, where k is the number of matches</li> <li>Nearest neighbor: O(log n) average</li> </ul> Thread Safety <p>Not thread-safe. Use external synchronization for concurrent access.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters are invalid or geometry is outside bounds.</p> Example <pre><code>qt = QuadTree((0.0, 0.0, 100.0, 100.0), capacity=10)\npoint_id = qt.insert((10.0, 20.0))\nresults = qt.query((5.0, 5.0, 25.0, 25.0))\nfor id_, x, y in results:\n    print(f\"Point {id_} at ({x}, {y})\")\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.insert","title":"<code>insert(geom, id_=None)</code>","text":"<p>Insert a single geometry.</p> <p>IDs are auto-assigned by default. You can optionally provide a custom ID to correlate with external data structures.</p> <p>Warning: Mixing auto-assigned and custom IDs is dangerous. The quadtree does not track which IDs have been used. If you provide a custom ID that collides with an auto-assigned ID, both entries will exist with the same ID, leading to undefined behavior. Users who provide custom IDs are responsible for ensuring uniqueness.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Geometry (Point or Bounds).</p> required <code>id_</code> <code>int | None</code> <p>Optional custom ID. If None, auto-assigns the next ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID used for this geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If geometry is outside the tree bounds.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.insert_many","title":"<code>insert_many(geoms)</code>","text":"<p>Bulk insert geometries with auto-assigned contiguous IDs.  IDs start at 0 and increment by 1, so they will be aligned with the indexes of the input list if the tree started empty. </p> <p>Custom IDs are not supported for bulk insertion. Use single insert() calls if you need custom IDs.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Sequence[G]</code> <p>Sequence of geometries.</p> required <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is a NumPy array (use insert_many_np instead).</p> <code>ValueError</code> <p>If any geometry is outside bounds.</p> Example <pre><code># Point Quadtree Example:\n\npoints = [(1.0, 2.0), (3.0, 4.0), (5.0, 6.0)]\nqt = QuadTree(bounds=(0.0, 0.0, 10.0, 10.0), capacity=16)\nresult = qt.insert_many(points) # Each point's ID corresponds to its index in the points list\nprint(result)  # InsertResult(count=3, start_id=0, end_id=2)\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.insert_many_np","title":"<code>insert_many_np(geoms)</code>","text":"<p>Bulk insert geometries from NumPy array with auto-assigned contiguous IDs.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Any</code> <p>NumPy array with dtype matching the tree's dtype.</p> required <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is not a NumPy array or dtype doesn't match.</p> <code>ValueError</code> <p>If any geometry is outside bounds.</p> <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.clear","title":"<code>clear()</code>","text":"<p>Empty the tree in place, preserving bounds, capacity, and max_depth.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.get_all_node_boundaries","title":"<code>get_all_node_boundaries()</code>","text":"<p>Return all node boundaries in the tree. Useful for visualization.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.get_inner_max_depth","title":"<code>get_inner_max_depth()</code>","text":"<p>Return the maximum depth of the quadtree.</p> <p>Useful if you constructed with max_depth=None.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.to_bytes","title":"<code>to_bytes()</code>","text":"<p>Serialize the quadtree to bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes representing the serialized quadtree.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.from_bytes","title":"<code>from_bytes(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a quadtree from bytes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes from to_bytes().</p> required <p>Returns:</p> Type Description <code>_BaseQuadTree[G]</code> <p>A new instance.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.query","title":"<code>query(rect)</code>","text":"<p>Find all points within a rectangular region.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>list[_IdCoord]</code> <p>List of (id, x, y) tuples for points inside the rectangle.</p> Example <pre><code>results = qt.query((10.0, 10.0, 20.0, 20.0))\nfor id_, x, y in results:\n    print(f\"Point {id_} at ({x}, {y})\")\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.query_np","title":"<code>query_np(rect)</code>","text":"<p>Find all points within a rectangular region, returning NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) where: - ids: NDArray[np.int64] with shape (N,) - coords: NDArray with shape (N, 2) and dtype matching the tree</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p> Example <pre><code>ids, coords = qt.query_np((10.0, 10.0, 20.0, 20.0))\nfor id_, (x, y) in zip(ids, coords):\n    print(f\"Point {id_} at ({x}, {y})\")\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.nearest_neighbor","title":"<code>nearest_neighbor(point)</code>","text":"<p>Return the single nearest neighbor to the query point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <p>Returns:</p> Type Description <code>_IdCoord | None</code> <p>Tuple of (id, x, y) or None if the tree is empty.</p> Example <pre><code>nn = qt.nearest_neighbor((15.0, 15.0))\nif nn is not None:\n    id_, x, y = nn\n    print(f\"Nearest: {id_} at ({x}, {y})\")\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.nearest_neighbor_np","title":"<code>nearest_neighbor_np(point)</code>","text":"<p>Return the single nearest neighbor as NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <p>Returns:</p> Type Description <code>tuple[int, Any] | None</code> <p>Tuple of (id, coords) or None if tree is empty, where: id: int (uint64) coords: NDArray with shape (2,) and dtype matching tree</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.nearest_neighbors","title":"<code>nearest_neighbors(point, k)</code>","text":"<p>Return the k nearest neighbors to the query point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>list[_IdCoord]</code> <p>List of (id, x, y) tuples in order of increasing distance.</p> Example <pre><code>neighbors = qt.nearest_neighbors((15.0, 15.0), k=5)\nfor id_, x, y in neighbors:\n    print(f\"Neighbor {id_} at ({x}, {y})\")\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.nearest_neighbors_np","title":"<code>nearest_neighbors_np(point, k)</code>","text":"<p>Return the k nearest neighbors as NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) where: ids: NDArray[np.uint64] with shape (k,) coords: NDArray with shape (k, 2) and dtype matching tree</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/quadtree/#fastquadtree.QuadTree.delete","title":"<code>delete(id_, x, y)</code>","text":"<p>Remove a point from the quadtree.</p> <p>Coordinates must be provided since this class doesn't store geometry internally.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>ID of the point to delete.</p> required <code>x</code> <code>float</code> <p>X coordinate of the point.</p> required <code>y</code> <code>float</code> <p>Y coordinate of the point.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the point was found and deleted, False if not found.</p> Example <pre><code>point_id = qt.insert((10.0, 20.0))\nsuccess = qt.delete(point_id, 10.0, 20.0)\nassert success is True\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.delete_tuple","title":"<code>delete_tuple(t)</code>","text":"<p>Remove a point from the quadtree using a tuple.</p> <p>This is a convenience method that accepts the point data as a single tuple, typically from query results.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>_IdCoord</code> <p>Tuple of (id, x, y) representing the point to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the point was found and deleted, False if not found.</p> Example <pre><code>point_id = qt.insert((10.0, 20.0))\nsuccess = qt.delete_tuple((point_id, 10.0, 20.0))\nassert success is True\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.update","title":"<code>update(id_, old_x, old_y, new_x, new_y)</code>","text":"<p>Move a point to new coordinates.</p> <p>Old coordinates must be provided since this class doesn't store geometry internally.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>ID of the point to move.</p> required <code>old_x</code> <code>float</code> <p>Current X coordinate.</p> required <code>old_y</code> <code>float</code> <p>Current Y coordinate.</p> required <code>new_x</code> <code>float</code> <p>New X coordinate.</p> required <code>new_y</code> <code>float</code> <p>New Y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded, False if the point was not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside tree bounds.</p> Example <pre><code>point_id = qt.insert((1.0, 1.0))\nsuccess = qt.update(point_id, 1.0, 1.0, 2.0, 2.0)\nassert success is True\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.update_tuple","title":"<code>update_tuple(id_, old_point, new_point)</code>","text":"<p>Move an existing point to a new location using tuple geometry.</p> <p>This is a convenience method that accepts geometry as tuples, reducing the number of parameters compared to update().</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID of the point to move.</p> required <code>old_point</code> <code>Point</code> <p>Current point as (x, y).</p> required <code>new_point</code> <code>Point</code> <p>New point as (x, y).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside bounds.</p> Example <pre><code>i = qt.insert((1.0, 1.0))\nok = qt.update_tuple(i, (1.0, 1.0), (2.0, 2.0))\nassert ok is True\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.__contains__","title":"<code>__contains__(point)</code>","text":"<p>Check if any item exists at the given point coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Point as (x, y).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one item exists at these coordinates.</p> Example <pre><code>qt.insert((10.0, 20.0))\nassert (10.0, 20.0) in qt\nassert (5.0, 5.0) not in qt\n</code></pre>"},{"location":"api/quadtree/#fastquadtree.QuadTree.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all (id, x, y) tuples in the tree.</p> Example <pre><code>for id_, x, y in qt:\n    print(f\"ID {id_} at ({x}, {y})\")\n</code></pre>"},{"location":"api/quadtree_objects/","title":"fastquadtree.QuadTreeObjects","text":"<p>A spatial index for 2D points with automatic Python object association.</p> <p>Parameter Name Clarification</p> <p>In the inherited methods below, the parameter <code>geom</code> refers to a point coordinate tuple <code>(x, y)</code>.</p> <p>For example:</p> <ul> <li><code>insert(geom, obj)</code> means <code>insert((x, y), obj)</code> - inserts a point with an associated object</li> <li><code>insert_many(geoms)</code> means <code>insert_many([(x1, y1), (x2, y2), ...])</code> when using coordinates only</li> </ul> <p>               Bases: <code>_BaseQuadTreeObjects[Point, PointItem]</code></p> <p>Spatial index for 2D points with Python object association.</p> <p>This class provides fast spatial indexing for points while allowing you to associate arbitrary Python objects with each point. IDs are managed internally using dense allocation for efficient lookup.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Bounds</code> <p>World bounds as (min_x, min_y, max_x, max_y).</p> required <code>capacity</code> <code>int</code> <p>Maximum points per node before splitting.</p> required <code>max_depth</code> <code>int | None</code> <p>Optional maximum tree depth (uses engine default if not specified).</p> <code>None</code> <code>dtype</code> <code>QuadTreeDType</code> <p>Coordinate data type ('f32', 'f64', 'i32', 'i64'). Default: 'f32'.</p> <code>'f32'</code> Performance <ul> <li>Inserts: O(log n) average</li> <li>Queries: O(log n + k) average, where k is the number of matches</li> <li>Nearest neighbor: O(log n) average</li> </ul> Thread Safety <p>Not thread-safe. Use external synchronization for concurrent access.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters are invalid or geometry is outside bounds.</p> Example <pre><code>qt = QuadTreeObjects((0.0, 0.0, 100.0, 100.0), capacity=10)\nid_ = qt.insert((10.0, 20.0), obj=\"my data\")\nresults = qt.query((5.0, 5.0, 25.0, 25.0))\nfor item in results:\n    print(f\"Point {item.id_} at ({item.x}, {item.y}) with obj={item.obj}\")\n</code></pre>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.insert","title":"<code>insert(geom, obj=None)</code>","text":"<p>Insert a single geometry with an optional associated object.</p> <p>IDs are auto-assigned using dense allocation for efficient object lookup. Custom IDs are not supported in Objects classes.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Geometry (Point or Bounds).</p> required <code>obj</code> <code>Any</code> <p>Optional Python object to associate with this geometry.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The auto-assigned ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If geometry is outside the tree bounds.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.insert_many","title":"<code>insert_many(geoms, objs=None)</code>","text":"<p>Bulk insert geometries with auto-assigned contiguous IDs.</p> Note <p>For performance, this method always appends new items and does not reuse IDs from the free-list created by deletions. Use insert() to fill holes.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Sequence[G]</code> <p>Sequence of geometries.</p> required <code>objs</code> <code>list[Any] | None</code> <p>Optional list of Python objects aligned with geoms.</p> <code>None</code> <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is a NumPy array (use insert_many_np instead).</p> <code>ValueError</code> <p>If any geometry is outside bounds or objs length doesn't match.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.insert_many_np","title":"<code>insert_many_np(geoms, objs=None)</code>","text":"<p>Bulk insert geometries from NumPy array with auto-assigned contiguous IDs.</p> Note <p>For performance, this method always appends new items and does not reuse IDs from the free-list created by deletions. Use insert() to fill holes.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Any</code> <p>NumPy array with dtype matching the tree's dtype.</p> required <code>objs</code> <code>list[Any] | None</code> <p>Optional list of Python objects aligned with geoms.</p> <code>None</code> <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is not a NumPy array or dtype doesn't match.</p> <code>ValueError</code> <p>If any geometry is outside bounds or objs length doesn't match.</p> <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.query","title":"<code>query(rect)</code>","text":"<p>Return all items that intersect/contain the query rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>list[ItemType]</code> <p>List of Item objects.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.query_ids","title":"<code>query_ids(rect)</code>","text":"<p>Return IDs of all items that intersect/contain the query rectangle.</p> <p>Fast path that only returns IDs without fetching items.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>List of integer IDs.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.query_np","title":"<code>query_np(rect)</code>","text":"<p>Return all items as NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) where ids is NDArray[np.int64] and coords matches tree dtype.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.nearest_neighbor","title":"<code>nearest_neighbor(point)</code>","text":"<p>Return the single nearest neighbor to the query point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <p>Returns:</p> Type Description <code>ItemType | None</code> <p>Item or None if the tree is empty.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.nearest_neighbor_np","title":"<code>nearest_neighbor_np(point)</code>","text":"<p>Return the single nearest neighbor as NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <p>Returns:</p> Type Description <code>tuple[int, Any] | None</code> <p>Tuple of (id, coords) or None if tree is empty.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.nearest_neighbors","title":"<code>nearest_neighbors(point, k)</code>","text":"<p>Return the k nearest neighbors to the query point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>list[ItemType]</code> <p>List of Item objects in order of increasing distance.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.nearest_neighbors_np","title":"<code>nearest_neighbors_np(point, k)</code>","text":"<p>Return the k nearest neighbors as NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) as NumPy arrays.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.delete","title":"<code>delete(id_)</code>","text":"<p>Delete an item by ID alone.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID of the item to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the item was found and deleted.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.delete_by_object","title":"<code>delete_by_object(obj)</code>","text":"<p>Delete all items with the given object (by identity, not equality).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to search for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of items deleted.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.delete_one_by_object","title":"<code>delete_one_by_object(obj)</code>","text":"<p>Delete one item with the given object (by identity).</p> <p>If multiple items have this object, deletes the one with the lowest ID.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to search for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an item was deleted.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.clear","title":"<code>clear()</code>","text":"<p>Empty the tree in place, preserving bounds, capacity, and max_depth.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.get","title":"<code>get(id_)</code>","text":"<p>Return the object associated with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID to look up.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The associated object or None if not found.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.attach","title":"<code>attach(id_, obj)</code>","text":"<p>Attach or replace the Python object for an existing ID.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID of the item.</p> required <code>obj</code> <code>Any</code> <p>The Python object to attach.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ID is not found.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.get_all_objects","title":"<code>get_all_objects()</code>","text":"<p>Return all tracked Python objects in the tree.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.get_all_items","title":"<code>get_all_items()</code>","text":"<p>Return all Item wrappers in the tree.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.__contains__","title":"<code>__contains__(geom)</code>","text":"<p>Check if any item exists at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Geometry to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one item exists at these exact coordinates.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all Item objects in the tree.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.get_all_node_boundaries","title":"<code>get_all_node_boundaries()</code>","text":"<p>Return all node boundaries in the tree. Useful for visualization.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.get_inner_max_depth","title":"<code>get_inner_max_depth()</code>","text":"<p>Return the maximum depth of the quadtree.</p> <p>Useful if you constructed with max_depth=None.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.to_bytes","title":"<code>to_bytes(include_objects=False)</code>","text":"<p>Serialize the quadtree to bytes.</p> Safety <ul> <li>include_objects=False (default): safe to load from untrusted data (no pickle executed)</li> <li>include_objects=True: includes a pickle section; unsafe for untrusted data</li> </ul> <p>Parameters:</p> Name Type Description Default <code>include_objects</code> <code>bool</code> <p>If True, serialize Python objects using pickle (unsafe).</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes representing the serialized quadtree.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.from_bytes","title":"<code>from_bytes(data, allow_objects=False)</code>  <code>classmethod</code>","text":"<p>Deserialize a quadtree from bytes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes from to_bytes().</p> required <code>allow_objects</code> <code>bool</code> <p>If True, load pickled Python objects (unsafe).           If False (default), object payloads are silently ignored.</p> <code>False</code> <p>Returns:</p> Type Description <code>_BaseQuadTreeObjects[G, ItemType]</code> <p>A new instance.</p> Note <p>Object deserialization uses pickle-like semantics. Never load serialized data from untrusted sources with allow_objects=True.</p>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.delete_at","title":"<code>delete_at(x, y)</code>","text":"<p>Delete an item at specific coordinates.</p> <p>If multiple items exist at the same point, deletes the one with the lowest ID.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an item was found and deleted, False otherwise.</p> Example <pre><code>qt.insert((5.0, 5.0))\nsuccess = qt.delete_at(5.0, 5.0)\nassert success is True\n</code></pre>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.update","title":"<code>update(id_, new_x, new_y)</code>","text":"<p>Move a point to new coordinates.</p> <p>This is efficient because old coordinates are retrieved from internal storage.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>ID of the point to move.</p> required <code>new_x</code> <code>float</code> <p>New X coordinate.</p> required <code>new_y</code> <code>float</code> <p>New Y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded, False if the ID was not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside tree bounds.</p> Example <pre><code>point_id = qt.insert((1.0, 1.0))\nsuccess = qt.update(point_id, 2.0, 2.0)\nassert success is True\n</code></pre>"},{"location":"api/quadtree_objects/#fastquadtree.QuadTreeObjects.update_by_object","title":"<code>update_by_object(obj, new_x, new_y)</code>","text":"<p>Move a point to new coordinates by finding it via its associated object.</p> <p>If multiple items have the same object, updates the one with the lowest ID.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Python object to search for (by identity).</p> required <code>new_x</code> <code>float</code> <p>New X coordinate.</p> required <code>new_y</code> <code>float</code> <p>New Y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded, False if object was not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside tree bounds.</p> Example <pre><code>my_obj = {\"data\": \"example\"}\nqt.insert((1.0, 1.0), obj=my_obj)\nsuccess = qt.update_by_object(my_obj, 2.0, 2.0)\nassert success is True\n</code></pre>"},{"location":"api/rect_item/","title":"fastquadtree.RectItem","text":"<p>               Bases: <code>Item[Bounds]</code></p> <p>Specialized item container for rectangle geometries.</p> <p>This subclass of Item adds convenient min_x, min_y, max_x, and max_y attributes for direct access to rectangle bounds.</p> <p>Attributes:</p> Name Type Description <code>id_</code> <code>int</code> <p>Integer identifier.</p> <code>geom</code> <code>G</code> <p>Rectangle geometry as (min_x, min_y, max_x, max_y) tuple.</p> <code>obj</code> <code>Any</code> <p>Associated Python object, or None if not set.</p> <code>min_x</code> <code>Any</code> <p>Minimum X coordinate (convenience accessor).</p> <code>min_y</code> <code>Any</code> <p>Minimum Y coordinate (convenience accessor).</p> <code>max_x</code> <code>Any</code> <p>Maximum X coordinate (convenience accessor).</p> <code>max_y</code> <code>Any</code> <p>Maximum Y coordinate (convenience accessor).</p>"},{"location":"api/rect_item/#fastquadtree.RectItem.id_","title":"<code>id_ = id_</code>  <code>instance-attribute</code>","text":""},{"location":"api/rect_item/#fastquadtree.RectItem.geom","title":"<code>geom = geom</code>  <code>instance-attribute</code>","text":""},{"location":"api/rect_item/#fastquadtree.RectItem.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":""},{"location":"api/rect_item/#fastquadtree.RectItem.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the item to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with 'id', 'geom', and 'obj' keys.</p>"},{"location":"api/rect_item/#fastquadtree.RectItem.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize an item from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'id', 'geom', and 'obj' keys.</p> required <p>Returns:</p> Type Description <code>Item</code> <p>Item instance populated with the deserialized data.</p>"},{"location":"api/rect_quadtree/","title":"fastquadtree.RectQuadTree","text":"<p>A spatial index for axis-aligned rectangles without object association.</p> <p>Parameter Name Clarification</p> <p>In the inherited methods below, the parameter <code>geom</code> refers to a rectangle coordinate tuple <code>(min_x, min_y, max_x, max_y)</code>.</p> <p>For example:</p> <ul> <li><code>insert(geom)</code> means <code>insert((min_x, min_y, max_x, max_y))</code></li> <li><code>insert_many(geoms)</code> means <code>insert_many([(min_x1, min_y1, max_x1, max_y1), ...])</code></li> </ul> <p>               Bases: <code>_BaseQuadTree[Bounds]</code></p> <p>Spatial index for axis-aligned rectangles without object association.</p> <p>This class provides fast spatial indexing for rectangles using integer IDs that you can correlate with external data structures. For automatic object association, see <code>RectQuadTreeObjects</code>.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Bounds</code> <p>World bounds as (min_x, min_y, max_x, max_y).</p> required <code>capacity</code> <code>int</code> <p>Maximum rectangles per node before splitting.</p> required <code>max_depth</code> <code>int | None</code> <p>Optional maximum tree depth (uses engine default if not specified).</p> <code>None</code> <code>dtype</code> <code>QuadTreeDType</code> <p>Coordinate data type ('f32', 'f64', 'i32', 'i64'). Default: 'f32'.</p> <code>'f32'</code> Performance <ul> <li>Inserts: O(log n) average</li> <li>Queries: O(log n + k) average, where k is the number of matches</li> <li>Nearest neighbor: O(log n) average</li> </ul> Thread Safety <p>Not thread-safe. Use external synchronization for concurrent access.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters are invalid or geometry is outside bounds.</p> Example <pre><code>rqt = RectQuadTree((0.0, 0.0, 100.0, 100.0), capacity=10)\nrect_id = rqt.insert((10.0, 20.0, 30.0, 40.0))\nresults = rqt.query((5.0, 5.0, 35.0, 35.0))\nfor id_, min_x, min_y, max_x, max_y in results:\n    print(f\"Rect {id_} at ({min_x}, {min_y}, {max_x}, {max_y})\")\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.insert","title":"<code>insert(geom, id_=None)</code>","text":"<p>Insert a single geometry.</p> <p>IDs are auto-assigned by default. You can optionally provide a custom ID to correlate with external data structures.</p> <p>Warning: Mixing auto-assigned and custom IDs is dangerous. The quadtree does not track which IDs have been used. If you provide a custom ID that collides with an auto-assigned ID, both entries will exist with the same ID, leading to undefined behavior. Users who provide custom IDs are responsible for ensuring uniqueness.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Geometry (Point or Bounds).</p> required <code>id_</code> <code>int | None</code> <p>Optional custom ID. If None, auto-assigns the next ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID used for this geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If geometry is outside the tree bounds.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.insert_many","title":"<code>insert_many(geoms)</code>","text":"<p>Bulk insert geometries with auto-assigned contiguous IDs.  IDs start at 0 and increment by 1, so they will be aligned with the indexes of the input list if the tree started empty. </p> <p>Custom IDs are not supported for bulk insertion. Use single insert() calls if you need custom IDs.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Sequence[G]</code> <p>Sequence of geometries.</p> required <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is a NumPy array (use insert_many_np instead).</p> <code>ValueError</code> <p>If any geometry is outside bounds.</p> Example <pre><code># Point Quadtree Example:\n\npoints = [(1.0, 2.0), (3.0, 4.0), (5.0, 6.0)]\nqt = QuadTree(bounds=(0.0, 0.0, 10.0, 10.0), capacity=16)\nresult = qt.insert_many(points) # Each point's ID corresponds to its index in the points list\nprint(result)  # InsertResult(count=3, start_id=0, end_id=2)\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.insert_many_np","title":"<code>insert_many_np(geoms)</code>","text":"<p>Bulk insert geometries from NumPy array with auto-assigned contiguous IDs.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Any</code> <p>NumPy array with dtype matching the tree's dtype.</p> required <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is not a NumPy array or dtype doesn't match.</p> <code>ValueError</code> <p>If any geometry is outside bounds.</p> <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.clear","title":"<code>clear()</code>","text":"<p>Empty the tree in place, preserving bounds, capacity, and max_depth.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.get_all_node_boundaries","title":"<code>get_all_node_boundaries()</code>","text":"<p>Return all node boundaries in the tree. Useful for visualization.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.get_inner_max_depth","title":"<code>get_inner_max_depth()</code>","text":"<p>Return the maximum depth of the quadtree.</p> <p>Useful if you constructed with max_depth=None.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.to_bytes","title":"<code>to_bytes()</code>","text":"<p>Serialize the quadtree to bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes representing the serialized quadtree.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.from_bytes","title":"<code>from_bytes(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a quadtree from bytes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes from to_bytes().</p> required <p>Returns:</p> Type Description <code>_BaseQuadTree[G]</code> <p>A new instance.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.query","title":"<code>query(rect)</code>","text":"<p>Find all rectangles that intersect with a query rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>list[_IdRect]</code> <p>List of (id, min_x, min_y, max_x, max_y) tuples for intersecting rectangles.</p> Example <pre><code>results = rqt.query((10.0, 10.0, 20.0, 20.0))\nfor id_, min_x, min_y, max_x, max_y in results:\n    print(f\"Rect {id_} at ({min_x}, {min_y}, {max_x}, {max_y})\")\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.query_np","title":"<code>query_np(rect)</code>","text":"<p>Find intersecting rectangles, returning NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) where: - ids: NDArray[np.int64] with shape (N,) - coords: NDArray with shape (N, 4) and dtype matching the tree</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p> Example <pre><code>ids, coords = rqt.query_np((10.0, 10.0, 20.0, 20.0))\nfor id_, (min_x, min_y, max_x, max_y) in zip(ids, coords):\n    print(f\"Rect {id_} at ({min_x}, {min_y}, {max_x}, {max_y})\")\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.nearest_neighbor","title":"<code>nearest_neighbor(point)</code>","text":"<p>Find the nearest rectangle to a query point.</p> <p>Distance is measured as Euclidean distance to the nearest edge of each rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point as (x, y).</p> required <p>Returns:</p> Type Description <code>_IdRect | None</code> <p>Tuple of (id, min_x, min_y, max_x, max_y), or None if tree is empty.</p> Example <pre><code>nn = rqt.nearest_neighbor((15.0, 15.0))\nif nn is not None:\n    id_, min_x, min_y, max_x, max_y = nn\n    print(f\"Nearest: {id_} at ({min_x}, {min_y}, {max_x}, {max_y})\")\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.nearest_neighbor_np","title":"<code>nearest_neighbor_np(point)</code>","text":"<p>Return the single nearest rectangle as NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <p>Returns:</p> Type Description <code>tuple[int, Any] | None</code> <p>Tuple of (id, coords) or None if tree is empty, where: id: int (uint64) coords: NDArray with shape (4,) and dtype matching tree</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.nearest_neighbors","title":"<code>nearest_neighbors(point, k)</code>","text":"<p>Return the k nearest rectangles to the query point.</p> <p>Uses Euclidean distance to the nearest edge of rectangles.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>list[_IdRect]</code> <p>List of (id, min_x, min_y, max_x, max_y) tuples in order of increasing distance.</p> Example <pre><code>neighbors = rqt.nearest_neighbors((15.0, 15.0), k=5)\nfor id_, min_x, min_y, max_x, max_y in neighbors:\n    print(f\"Neighbor {id_} at ({min_x}, {min_y}, {max_x}, {max_y})\")\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.nearest_neighbors_np","title":"<code>nearest_neighbors_np(point, k)</code>","text":"<p>Return the k nearest rectangles as NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) where: ids: NDArray[np.uint64] with shape (k,) coords: NDArray with shape (k, 4) and dtype matching tree</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.delete","title":"<code>delete(id_, min_x, min_y, max_x, max_y)</code>","text":"<p>Remove a rectangle from the quadtree.</p> <p>Coordinates must be provided since this class doesn't store geometry internally.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>ID of the rectangle to delete.</p> required <code>min_x</code> <code>float</code> <p>Minimum x coordinate of the rectangle.</p> required <code>min_y</code> <code>float</code> <p>Minimum y coordinate of the rectangle.</p> required <code>max_x</code> <code>float</code> <p>Maximum x coordinate of the rectangle.</p> required <code>max_y</code> <code>float</code> <p>Maximum y coordinate of the rectangle.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the rectangle was found and deleted, False if not found.</p> Example <pre><code>rect_id = rqt.insert((10.0, 20.0, 30.0, 40.0))\nsuccess = rqt.delete(rect_id, 10.0, 20.0, 30.0, 40.0)\nassert success is True\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.delete_tuple","title":"<code>delete_tuple(t)</code>","text":"<p>Remove a rectangle from the quadtree using a tuple.</p> <p>This is a convenience method that accepts the rectangle data as a single tuple, typically from query results.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>_IdRect</code> <p>Tuple of (id, min_x, min_y, max_x, max_y) representing the rectangle to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the rectangle was found and deleted, False if not found.</p> Example <pre><code>rect_id = rqt.insert((10.0, 20.0, 30.0, 40.0))\nsuccess = rqt.delete_tuple((rect_id, 10.0, 20.0, 30.0, 40.0))\nassert success is True\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.update","title":"<code>update(id_, old_min_x, old_min_y, old_max_x, old_max_y, new_min_x, new_min_y, new_max_x, new_max_y)</code>","text":"<p>Move an existing rectangle to a new location.</p> <p>Old geometry is required because this class doesn't store it.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID of the rectangle to move.</p> required <code>old_min_x</code> <code>float</code> <p>Current min x coordinate.</p> required <code>old_min_y</code> <code>float</code> <p>Current min y coordinate.</p> required <code>old_max_x</code> <code>float</code> <p>Current max x coordinate.</p> required <code>old_max_y</code> <code>float</code> <p>Current max y coordinate.</p> required <code>new_min_x</code> <code>float</code> <p>New min x coordinate.</p> required <code>new_min_y</code> <code>float</code> <p>New min y coordinate.</p> required <code>new_max_x</code> <code>float</code> <p>New max x coordinate.</p> required <code>new_max_y</code> <code>float</code> <p>New max y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside bounds.</p> Example <pre><code>i = rqt.insert((1.0, 1.0, 2.0, 2.0))\nok = rqt.update(i, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0)\nassert ok is True\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.update_tuple","title":"<code>update_tuple(id_, old_rect, new_rect)</code>","text":"<p>Move an existing rectangle to a new location using tuple geometry.</p> <p>This is a convenience method that accepts geometry as tuples, reducing the number of parameters compared to update().</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID of the rectangle to move.</p> required <code>old_rect</code> <code>Bounds</code> <p>Current rectangle as (min_x, min_y, max_x, max_y).</p> required <code>new_rect</code> <code>Bounds</code> <p>New rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside bounds.</p> Example <pre><code>i = rqt.insert((1.0, 1.0, 2.0, 2.0))\nok = rqt.update_tuple(i, (1.0, 1.0, 2.0, 2.0), (3.0, 3.0, 4.0, 4.0))\nassert ok is True\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.__contains__","title":"<code>__contains__(rect)</code>","text":"<p>Check if any item exists at the given rectangle coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one item exists at these exact coordinates.</p> Example <pre><code>rqt.insert((10.0, 20.0, 30.0, 40.0))\nassert (10.0, 20.0, 30.0, 40.0) in rqt\nassert (5.0, 5.0, 10.0, 10.0) not in rqt\n</code></pre>"},{"location":"api/rect_quadtree/#fastquadtree.RectQuadTree.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all (id, min_x, min_y, max_x, max_y) tuples in the tree.</p> Example <pre><code>for id_, min_x, min_y, max_x, max_y in rqt:\n    print(f\"ID {id_} at ({min_x}, {min_y}, {max_x}, {max_y})\")\n</code></pre>"},{"location":"api/rect_quadtree_objects/","title":"fastquadtree.RectQuadTreeObjects","text":"<p>A spatial index for axis-aligned rectangles with automatic Python object association.</p> <p>Parameter Name Clarification</p> <p>In the inherited methods below, the parameter <code>geom</code> refers to a rectangle coordinate tuple <code>(min_x, min_y, max_x, max_y)</code>.</p> <p>For example:</p> <ul> <li><code>insert(geom, obj)</code> means <code>insert((min_x, min_y, max_x, max_y), obj)</code> - inserts a rectangle with an associated object</li> <li><code>insert_many(geoms)</code> means <code>insert_many([(min_x1, min_y1, max_x1, max_y1), ...])</code> when using coordinates only</li> </ul> <p>               Bases: <code>_BaseQuadTreeObjects[Bounds, RectItem]</code></p> <p>Spatial index for axis-aligned rectangles with Python object association.</p> <p>This class provides fast spatial indexing for rectangles while allowing you to associate arbitrary Python objects with each rectangle. IDs are managed internally using dense allocation for efficient lookup.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Bounds</code> <p>World bounds as (min_x, min_y, max_x, max_y).</p> required <code>capacity</code> <code>int</code> <p>Maximum rectangles per node before splitting.</p> required <code>max_depth</code> <code>int | None</code> <p>Optional maximum tree depth (uses engine default if not specified).</p> <code>None</code> <code>dtype</code> <code>QuadTreeDType</code> <p>Coordinate data type ('f32', 'f64', 'i32', 'i64'). Default: 'f32'.</p> <code>'f32'</code> Performance <ul> <li>Inserts: O(log n) average</li> <li>Queries: O(log n + k) average, where k is the number of matches</li> <li>Nearest neighbor: O(log n) average</li> </ul> Thread Safety <p>Not thread-safe. Use external synchronization for concurrent access.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters are invalid or geometry is outside bounds.</p> Example <pre><code>rqt = RectQuadTreeObjects((0.0, 0.0, 100.0, 100.0), capacity=10)\nrect_id = rqt.insert((10.0, 20.0, 30.0, 40.0), obj=\"my data\")\nresults = rqt.query((5.0, 5.0, 35.0, 35.0))\nfor item in results:\n    print(f\"Rect {item.id_} at ({item.min_x}, {item.min_y}, {item.max_x}, {item.max_y})\")\n</code></pre>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.insert","title":"<code>insert(geom, obj=None)</code>","text":"<p>Insert a single geometry with an optional associated object.</p> <p>IDs are auto-assigned using dense allocation for efficient object lookup. Custom IDs are not supported in Objects classes.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Geometry (Point or Bounds).</p> required <code>obj</code> <code>Any</code> <p>Optional Python object to associate with this geometry.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The auto-assigned ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If geometry is outside the tree bounds.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.insert_many","title":"<code>insert_many(geoms, objs=None)</code>","text":"<p>Bulk insert geometries with auto-assigned contiguous IDs.</p> Note <p>For performance, this method always appends new items and does not reuse IDs from the free-list created by deletions. Use insert() to fill holes.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Sequence[G]</code> <p>Sequence of geometries.</p> required <code>objs</code> <code>list[Any] | None</code> <p>Optional list of Python objects aligned with geoms.</p> <code>None</code> <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is a NumPy array (use insert_many_np instead).</p> <code>ValueError</code> <p>If any geometry is outside bounds or objs length doesn't match.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.insert_many_np","title":"<code>insert_many_np(geoms, objs=None)</code>","text":"<p>Bulk insert geometries from NumPy array with auto-assigned contiguous IDs.</p> Note <p>For performance, this method always appends new items and does not reuse IDs from the free-list created by deletions. Use insert() to fill holes.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>Any</code> <p>NumPy array with dtype matching the tree's dtype.</p> required <code>objs</code> <code>list[Any] | None</code> <p>Optional list of Python objects aligned with geoms.</p> <code>None</code> <p>Returns:</p> Type Description <code>InsertResult</code> <p>InsertResult with count, start_id, and end_id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geoms is not a NumPy array or dtype doesn't match.</p> <code>ValueError</code> <p>If any geometry is outside bounds or objs length doesn't match.</p> <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.query","title":"<code>query(rect)</code>","text":"<p>Return all items that intersect/contain the query rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>list[ItemType]</code> <p>List of Item objects.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.query_ids","title":"<code>query_ids(rect)</code>","text":"<p>Return IDs of all items that intersect/contain the query rectangle.</p> <p>Fast path that only returns IDs without fetching items.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>List of integer IDs.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.query_np","title":"<code>query_np(rect)</code>","text":"<p>Return all items as NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Bounds</code> <p>Query rectangle as (min_x, min_y, max_x, max_y).</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) where ids is NDArray[np.int64] and coords matches tree dtype.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.nearest_neighbor","title":"<code>nearest_neighbor(point)</code>","text":"<p>Return the single nearest neighbor to the query point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <p>Returns:</p> Type Description <code>ItemType | None</code> <p>Item or None if the tree is empty.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.nearest_neighbor_np","title":"<code>nearest_neighbor_np(point)</code>","text":"<p>Return the single nearest neighbor as NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <p>Returns:</p> Type Description <code>tuple[int, Any] | None</code> <p>Tuple of (id, coords) or None if tree is empty.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.nearest_neighbors","title":"<code>nearest_neighbors(point, k)</code>","text":"<p>Return the k nearest neighbors to the query point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>list[ItemType]</code> <p>List of Item objects in order of increasing distance.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.nearest_neighbors_np","title":"<code>nearest_neighbors_np(point, k)</code>","text":"<p>Return the k nearest neighbors as NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Query point (x, y).</p> required <code>k</code> <code>int</code> <p>Number of neighbors to return.</p> required <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Tuple of (ids, coords) as NumPy arrays.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If NumPy is not installed.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.delete","title":"<code>delete(id_)</code>","text":"<p>Delete an item by ID alone.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID of the item to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the item was found and deleted.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.delete_by_object","title":"<code>delete_by_object(obj)</code>","text":"<p>Delete all items with the given object (by identity, not equality).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to search for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of items deleted.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.delete_one_by_object","title":"<code>delete_one_by_object(obj)</code>","text":"<p>Delete one item with the given object (by identity).</p> <p>If multiple items have this object, deletes the one with the lowest ID.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to search for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an item was deleted.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.clear","title":"<code>clear()</code>","text":"<p>Empty the tree in place, preserving bounds, capacity, and max_depth.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.get","title":"<code>get(id_)</code>","text":"<p>Return the object associated with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID to look up.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The associated object or None if not found.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.attach","title":"<code>attach(id_, obj)</code>","text":"<p>Attach or replace the Python object for an existing ID.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>The ID of the item.</p> required <code>obj</code> <code>Any</code> <p>The Python object to attach.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ID is not found.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.get_all_objects","title":"<code>get_all_objects()</code>","text":"<p>Return all tracked Python objects in the tree.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.get_all_items","title":"<code>get_all_items()</code>","text":"<p>Return all Item wrappers in the tree.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.__contains__","title":"<code>__contains__(geom)</code>","text":"<p>Check if any item exists at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>G</code> <p>Geometry to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one item exists at these exact coordinates.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all Item objects in the tree.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.get_all_node_boundaries","title":"<code>get_all_node_boundaries()</code>","text":"<p>Return all node boundaries in the tree. Useful for visualization.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.get_inner_max_depth","title":"<code>get_inner_max_depth()</code>","text":"<p>Return the maximum depth of the quadtree.</p> <p>Useful if you constructed with max_depth=None.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.to_bytes","title":"<code>to_bytes(include_objects=False)</code>","text":"<p>Serialize the quadtree to bytes.</p> Safety <ul> <li>include_objects=False (default): safe to load from untrusted data (no pickle executed)</li> <li>include_objects=True: includes a pickle section; unsafe for untrusted data</li> </ul> <p>Parameters:</p> Name Type Description Default <code>include_objects</code> <code>bool</code> <p>If True, serialize Python objects using pickle (unsafe).</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes representing the serialized quadtree.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.from_bytes","title":"<code>from_bytes(data, allow_objects=False)</code>  <code>classmethod</code>","text":"<p>Deserialize a quadtree from bytes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes from to_bytes().</p> required <code>allow_objects</code> <code>bool</code> <p>If True, load pickled Python objects (unsafe).           If False (default), object payloads are silently ignored.</p> <code>False</code> <p>Returns:</p> Type Description <code>_BaseQuadTreeObjects[G, ItemType]</code> <p>A new instance.</p> Note <p>Object deserialization uses pickle-like semantics. Never load serialized data from untrusted sources with allow_objects=True.</p>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.delete_at","title":"<code>delete_at(min_x, min_y, max_x, max_y)</code>","text":"<p>Delete a rectangle at specific coordinates.</p> <p>If multiple rectangles exist at the same coordinates, deletes the one with the lowest ID.</p> <p>Parameters:</p> Name Type Description Default <code>min_x</code> <code>float</code> <p>Minimum X coordinate.</p> required <code>min_y</code> <code>float</code> <p>Minimum Y coordinate.</p> required <code>max_x</code> <code>float</code> <p>Maximum X coordinate.</p> required <code>max_y</code> <code>float</code> <p>Maximum Y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a rectangle was found and deleted, False otherwise.</p> Example <pre><code>rqt.insert((5.0, 5.0, 10.0, 10.0))\nsuccess = rqt.delete_at(5.0, 5.0, 10.0, 10.0)\nassert success is True\n</code></pre>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.update","title":"<code>update(id_, new_min_x, new_min_y, new_max_x, new_max_y)</code>","text":"<p>Move a rectangle to new coordinates.</p> <p>This is efficient because old coordinates are retrieved from internal storage.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>ID of the rectangle to move.</p> required <code>new_min_x</code> <code>float</code> <p>New minimum X coordinate.</p> required <code>new_min_y</code> <code>float</code> <p>New minimum Y coordinate.</p> required <code>new_max_x</code> <code>float</code> <p>New maximum X coordinate.</p> required <code>new_max_y</code> <code>float</code> <p>New maximum Y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded, False if the ID was not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside tree bounds.</p> Example <pre><code>rect_id = rqt.insert((1.0, 1.0, 2.0, 2.0))\nsuccess = rqt.update(rect_id, 3.0, 3.0, 4.0, 4.0)\nassert success is True\n</code></pre>"},{"location":"api/rect_quadtree_objects/#fastquadtree.RectQuadTreeObjects.update_by_object","title":"<code>update_by_object(obj, new_min_x, new_min_y, new_max_x, new_max_y)</code>","text":"<p>Move a rectangle to new coordinates by finding it via its associated object.</p> <p>If multiple items have the same object, updates the one with the lowest ID.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Python object to search for (by identity).</p> required <code>new_min_x</code> <code>float</code> <p>New minimum X coordinate.</p> required <code>new_min_y</code> <code>float</code> <p>New minimum Y coordinate.</p> required <code>new_max_x</code> <code>float</code> <p>New maximum X coordinate.</p> required <code>new_max_y</code> <code>float</code> <p>New maximum Y coordinate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update succeeded, False if object was not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If new coordinates are outside tree bounds.</p> Example <pre><code>my_obj = {\"data\": \"example\"}\nrqt.insert((1.0, 1.0, 2.0, 2.0), obj=my_obj)\nsuccess = rqt.update_by_object(my_obj, 3.0, 3.0, 4.0, 4.0)\nassert success is True\n</code></pre>"}]}